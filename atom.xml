<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin&#39; blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dupengchuan.github.io/"/>
  <updated>2016-06-02T11:06:14.297Z</updated>
  <id>http://dupengchuan.github.io/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机是如何启动的？</title>
    <link href="http://dupengchuan.github.io/2016/06/02/how-computers-boot-up/"/>
    <id>http://dupengchuan.github.io/2016/06/02/how-computers-boot-up/</id>
    <published>2016-06-02T05:53:30.000Z</published>
    <updated>2016-06-02T11:06:14.297Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文来自&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gustavo Duarte的博客&lt;/a&gt;，本人出于兴趣翻译过来，原文地址：&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-computers-boot-up/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How Computer Boot up&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面的一篇博文讲述了Intel计算机的&lt;a href=&quot;http://dupengchuan.me/2016/05/31/motherboard-chipsets-and-the-memory-map/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;主板芯片结构以及内存映射&lt;/a&gt;，这些属于为计算机启动的初始化阶段，计算机启动是一个复杂多阶段并且有趣的过程。下面是一个流程图：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/_N-Mf1KiaxbqiX8V5WCyfg==/6631579038605486672.png&quot; alt=&quot;bootProcess&quot;&gt;&lt;/p&gt;
&lt;p&gt;当你按下开机键的时候，一切变开始运转了。主板一旦被供电，它就初始化自己的固件（芯片组和其他附属组件）并启动CPU。如果此时硬件失败（比如CPU故障或者不存在），那么你的系统很有可能除了那旋转的风扇什么反应都没有。一些主板可能会发出蜂鸣告警CPU故障或者缺失，但据我的经验，风扇故障是最常见的情况。甚至有时候USB或者其它也设备能够引起这种情况发生，这时候拔下一些不必要的设备是一个解决办法。你可以通过逐步移除的方法来定位故障设备。&lt;/p&gt;
&lt;p&gt;如果一切顺利，CPU开始运行。在多处理器或者多核的系统，一个CPU核心被动态的选择成为引导处理器（BSP），然后运行所有的BIOS和kernel初始化代码。其余的处理器称为应用处理器（AP），这时候它们依旧停留在原来的状态直到后来被内核激活。Intel的CPU已经发展了那么多年，但它们是完全向后兼容，所以现代的CPU和1978年的&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_8086&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;intel 8086&lt;/a&gt;启动还是很相似，上电之后它们做哪些工作是很已经确定的。在上电后的早期状态，处理器在处在&lt;a href=&quot;http://en.wikipedia.org/wiki/Real_mode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实模式&lt;/a&gt;（禁用内存&lt;a href=&quot;http://en.wikipedia.org/wiki/Paging&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;分页&lt;/a&gt;）。这个就像早期的MS-DOS系统，可以寻址1MB内存空间，并且任何代码都可以存放在该空间的任何位置，这里没有内存保护和特权的概念。&lt;/p&gt;
&lt;p&gt;CPU的大部分&lt;a href=&quot;http://en.wikipedia.org/wiki/Processor_register&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;寄存器&lt;/a&gt;都有已经定义好的明确的功能，比如指令指针（EIP）寄存器，里面存储了CPU正在执行的指令的内存地址。Intel CPU使用基址寻址访问向量程序。即使上电时只有1MB的的内存可以被访问，一个隐藏的基址（本质上是一个偏移量）被加到EIP,因此第一条指令在0xFFFFFFF0(4G内存的最后16个字节，远远高于1M空间)。这个神奇的地址被称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Reset_vector&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;复位向量&lt;/a&gt;，是现代化CPU的一个标准。&lt;/p&gt;
&lt;p&gt;主板确保在复位向量的跳转指令可跳转到存储器上BIOS程序的入口点。这个跳转指令也隐含清除了上电的时候产生的基址。所有的这些存储单元都有CPU需要的内容。这多亏了芯片（包括BIOS）的&lt;a href=&quot;http://duartes.org/gustavo/blog/post/motherboard-chipsets-memory-map&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存映射&lt;/a&gt;机制。此时RAM模块在这些区域之间也存在没有被使用的内存。内存区域相关的例子如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.ph.126.net/nUyi_jsfkqNY5i1PwMwA9g==/4939322891419790476.png&quot; alt=&quot;bootMemoryRegions&quot;&gt;&lt;/p&gt;
&lt;p&gt;CPU跳转到BIOS程序并执行，初始化一些硬件。之后BIOS开始进行&lt;a href=&quot;http://en.wikipedia.org/wiki/Power_on_self_test&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上电自检&lt;/a&gt;（POST），这个过程中检测各种计算机组件。如果缺少显卡会引发BIOS程序停止，并且发出蜂鸣警告，这样你就知道哪里出了问题（由于显卡出了问题，所以不可能从屏幕获得信息）。如果显卡正常运行，我们可能感觉计算机好像是正常的：制造商的商标打印了，内存也开始检测。其他的自检失败，像缺少键盘将会导致BIOS停止并将错误信息显示在屏幕上。POST包括硬件检测和初始化，POST之后会整理出所有资源-中断、内存范围、I/O端口（PCI设备）。现代的BIOS根据进行&lt;a href=&quot;http://en.wikipedia.org/wiki/ACPI&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;高级配置和启动选项&lt;/a&gt;，建立一个启动表，里面保存了计算机上的设备，这个表稍后将会被内核用到。&lt;/p&gt;
&lt;p&gt;POST之后，BIOS准备启动一个操作系统，首先要找到操作系统在哪里：硬盘，CD-ROM，软盘等等，这里，用户可以配置BIOS的选择启动设备的顺序。BIOS如果没有合适的启动设备，就会给出信息： “Non-System Disk Error”。一个坏掉的硬盘可能会导致这个问题。但愿不要这样，希望BIOS找到一个正常工作的硬盘顺利启动。&lt;/p&gt;
&lt;p&gt;BIOS读取硬盘的第一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Disk_sector&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;扇区&lt;/a&gt;的512个字节。这个被称作&lt;a href=&quot;http://en.wikipedia.org/wiki/Master_boot_record&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;主引导记录&lt;/a&gt;，通常它包括两部分：操作系统相关的引导程序和磁盘分区表。BIOS并不关心它们有什么用，BIOS只是仅仅将这个512字节加载到内存的0x7c00的位置，然后跳转到MBR中的引导程序继续执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img0.ph.126.net/c5QoVMKGUiOOubfIdSLraA==/6631565844465954720.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;MBR中的引导程序可以是Windows的MBR loader,或者是Linux loader比如LILO或者GRUB,或者甚至有可能是一个病毒。相比较引导程序，分区表则是标准化的格式：它总共长64个字节，16个字节表示一个分区（所以在一个磁盘上可以有不同分区也可以有不同的系统）。通常，Microsoft MBR代码会查看分区表，找到那个被标记为活动状态的分区，加载该分区上引导扇区，并运行上面的代码。引导扇区是一个分区的第一个扇区，注意和磁盘的第一个扇区的区别不一样。如果分区表上有错误，你会看到：“无效的分区表”或者“找不到操作系统”。这些消息不是来自BIOS，而是来自MBR上的引导程序。至于消息的内容与特定的MBR引导程序有关。&lt;/p&gt;
&lt;p&gt;随着时代的发展，引导程序已经变得越来越复杂和灵活。Linux引导程序LILO和GRUB可以引导多种操作系统、文件系统而且可以被配置。它们的MBR代码已经不是必须引导上面所说的活动分区。功能上的流程如下：&lt;/p&gt;
&lt;p&gt;MBR包括boot loader的第一阶段，GRUB就在这个阶段。&lt;/p&gt;
&lt;p&gt;由于MBR空间有限，MBR没有足够的空间加载从磁盘加载包含其他引导代码的扇区。这个扇区有可能是这个分区的引导扇区，但是也可以被硬编码到MBR代码区。&lt;/p&gt;
&lt;p&gt;MBR代码加上那些在第二步加载代码，然后读取一个包含bootloader第二阶段代码的文件。GRUB中是grub/stage2,Windows中是c:\NTLDR。如果步骤2失败，Windows系统你会得到像：“NTLDR is missing”。阶段2的代码读取一个启动配置文件（linux中是grub.conf，windows中是boot.ini）。然后展示用户选择启动系统的界面或者是直接启动系统（仅仅存在一个启动项）&lt;/p&gt;
&lt;p&gt;此时，bootloader代买需要启动一个内核。它必须知道文件系统是什么然后才可以去分区读取内核。在Linux中，这意味着去读取名字差不多是“vmlinuz-2.6.22-14-server”的文件，加载进内存并且跳转到内核启动代码。在WIndows2003中，一些内核启动代码和内核镜像是分开的。实际上嵌入到了NYLDR文件中。进行几个初始化之后，NTDLR才加载镜像c:\Windows\System32\ntoskrnl.exe。然后就想GRUB做的一样，跳转到内核的程序执行。&lt;/p&gt;
&lt;p&gt;这里有一个值得一提的问题（）。当前的Linux 内核镜像即使经过压缩，也不能放进RAM最开始地那640K地址空间(实模式下可访问)。我的Ubuntu内核压缩之后是1.7M。但是bootloader通过BIOS读取磁盘数据必须运行在实模式中，因此内核显然是获取不到的。解决办法就是引入了&lt;a href=&quot;http://en.wikipedia.org/wiki/Unreal_mode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;虚拟模式&lt;/a&gt;。这个并不是一个真正的处理器模式（我希望Intel的工程师被允许在这方面有兴趣），但是是一项技术，程序为了能够通过BIOS访问超过1MB以上的地址空间在实模式和保护模式之间切换。如果你读过GRUB源码，你会看到这些转换（看stage2中的real_to_prot和prot_to_real）。当BIOS将内核加载到内存中，最后处理器又会切换回实模式。&lt;/p&gt;
&lt;p&gt;正如图1中展示的，我们现在处在从“引导加载程序”到“早期的内核初始化”阶段。接下来的事情会变得麻烦，内核解压，动态初始化。下一篇文章是Linux内核初始化的一个介绍，我会给出源码的连接。当然Windows我不能这样做。但是我会指出值得注意的地方。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot;&gt;Gustavo Duarte的博客&lt;/a&gt;，本人出于兴趣翻译过来，原文地址：&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-computers-boot-up/&quot;&gt;How Computer Boot up&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面的一篇博文讲述了Intel计算机的&lt;a href=&quot;http://dupengchuan.me/2016/05/31/motherboard-chipsets-and-the-memory-map/&quot;&gt;主板芯片结构以及内存映射&lt;/a&gt;，这些属于为计算机启动的初始化阶段，计算机启动是一个复杂多阶段并且有趣的过程。下面是一个流程图：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Arch" scheme="http://dupengchuan.github.io/tags/Arch/"/>
    
  </entry>
  
  <entry>
    <title>主板芯片和内存映射原理</title>
    <link href="http://dupengchuan.github.io/2016/05/31/motherboard-chipsets-and-the-memory-map/"/>
    <id>http://dupengchuan.github.io/2016/05/31/motherboard-chipsets-and-the-memory-map/</id>
    <published>2016-05-31T08:37:10.000Z</published>
    <updated>2016-06-02T05:52:15.090Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;这篇博文翻译自&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gustavo Duarte&lt;/a&gt;博客上的一篇博文，笔者出于兴趣，同时也是学习，翻译过来，原文： &lt;a href=&quot;http://duartes.org/gustavo/blog/post/motherboard-chipsets-memory-map/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Motherboard Chipsets and the Memory Map&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了阐明现在操作系统内核如何工作，我打算写一些关于计算机内部实现原理的文章。希望对那些对这方面有兴趣但是却没有经验的电脑爱好者和程序员们有所帮助。计算机的内部实现是我的一个爱好，因此我们主要关注点在Linux、Windows操作系统以及Intel处理器。这篇博文主要讲述了基于Intel处理器的主板布局，CPU怎么样访问内存以及系统内存映射。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先让我们看一下现代基于Intel处理器的计算机架构是什么样子的。下面这幅图主要展示了主板上的主要组件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/syfL7tvt2FaivsIy765tJg==/4819414551340637687.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现代主板由南桥芯片组和北桥芯片组构成&lt;/p&gt;
&lt;p&gt;看到这幅图，记住最关键一点，那就是CPU不知道他连接的是什么设备。CPU通过引脚连接外面的世界，但是它不关心连接的是什么。虽然可能是一台计算机的主板，但是也有可能是烤面包机，网络路由器，CPU实验板等等。CPU有三种方式和外面通信：内存地址、IO地址和中断。我们现在只讨论主板和内存。&lt;/p&gt;
&lt;p&gt;CPU通往外面的大门是连接到北桥的前端总线，CPU通过前端总线读写内存。它使用一些引脚传送它想要读或者写的物理内存地址，使用另外一些引脚传送或者接收数据。Intel Core2 QX6600有33根传送内存地址的引脚（地址空间2^33个内存地址）和64根发送和接收数据的引脚（数据宽度是64bit或者8字节）。这允许CPU能够寻址的内存空间大小为64GB（2^33 * 8 byte）尽管大部分的芯片只使用了8G的内存。&lt;/p&gt;
&lt;p&gt;我们曾经认为程序不停地读取和写入的只有RAM,事实上大部分内存请求也是经过北桥芯片到了RAM模块，但并不是全部。内存物理地址也可以映射到各种各样的主板上的设备上（这种通信被称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Memory-mapped_IO&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存映射I/O&lt;/a&gt;）。这些设备有显卡、大部分PCI设备（比图，扫描仪或者SCSI卡）以及存储BIOS程序的&lt;a href=&quot;http://en.wikipedia.org/wiki/Flash_memory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;闪存&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当北桥芯片接收到一个内存请求，北桥芯片根据内存地址映射决定最终请求的设备是RAM还是显卡。对于每一个内存地址段，通过内存映射可以知道属于哪个设备。地址空间的大部分地址映射到了RAM,但是当如果没有内存映射告诉芯片哪个设备需要处理这些请求，那些不在RAM的地址空间就造成了内存地址空洞（640KB-1MB这部分地址是设备使用的但是如果没有设备使用就相当于这段内存没有用）。当内存地址为显卡和PCI设备预留了地址空间的时候，将会引起更大的空洞。这也就是&lt;a href=&quot;http://support.microsoft.com/kb/929605&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;为什么32位的操作系统在使用4GRAM的时候会出问题&lt;/a&gt;。下面的这幅图展示了一个4G地址空间上的一个内存映射。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/TMKxjy78Awc82dLBKfijVA==/6631513067907784718.png&quot; alt=&quot;memoryLayout&quot;&gt;&lt;/p&gt;
&lt;p&gt;Intel系统前4G内存模型&lt;/p&gt;
&lt;p&gt;实际的地址范围取决于具体的主板和实际的设备，但是大部分的Core 2系统和上面很类似。所有的褐色段被映射到RAM之外的设备。这些地址可以被主板总线直接使用。而在CPU内部（比如，运行的程序需要写）这些地址是逻辑地址，它们在被总线访问之前必须先被CPU转成物理地址。&lt;/p&gt;
&lt;p&gt;逻辑地址转换为物理地址的过程比较复杂，依赖于CPU运行模式（实模式、32位保护模式和64位保护模式）。不考虑内存转换机制，CPU的模式决定了可以访问多大物理地址空间。比如，如果CPU运行在32位保护模式，那么它的寻址空间是4GB(但是开启&lt;a href=&quot;http://en.wikipedia.org/wiki/Physical_address_extension&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Physical Address Extension&lt;/a&gt;是个例外，这里暂不讨论)。由于最前面的大约1GB内存映射给主板设备，CPU能够实际使用的只有1~3GB的RAM空间（有时候会更少-我的Vista系统只有2.4G可用）。如果CPU运行在&lt;a href=&quot;http://en.wikipedia.org/wiki/Real_mode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实模式&lt;/a&gt;（系统启动早期使用的模式），那么它能够寻址1GB的RAM空间。另外，64位保护模式可以寻址64GB内存空间（虽然很少有芯片支持）。在64位模式，系统在访问那些被主板设备占据的内存的时候,有可能使用超过总RAM的物理地址空间。这就是所谓的可回收内存，在芯片的支持下完成。&lt;/p&gt;
&lt;p&gt;下一篇我们将讲述系统启动过程，从按开机键到bootloader跳转到内核，将控制权交给内核。如果你想要了解更多关于这方面的内容，我强烈推荐你看&lt;a href=&quot;http://www.intel.cn/content/www/cn/zh/processors/architectures-software-developer-manuals.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intel手册&lt;/a&gt;。我是从大的方向把握，但Intel手册写上面的非常详细和准确。这里列举一些。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://download.intel.com/design/chipsets/datashts/31760701.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intel G35 参考手册&lt;/a&gt;描述了一些支持Core 2的代表性芯片。是本篇博文的主要来源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://download.intel.com/design/processor/datashts/31559205.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intel Core 2 Quad-Core-Q600 参考手册&lt;/a&gt;是一个处理器手册。它介绍了处理器上面的每个引脚（实际上并没有太大的实际意义，如果你对它们进行分类，发现也没有多少）。很神秘，也很让人着迷。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.intel.com/products/processor/manuals/index.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intel 软件开发手册&lt;/a&gt;都很不错。通俗全面地阐明了有关架构的各种事情。卷1和卷3A有一些很不错的内容（不要被卷这个字吓到，这个卷很小，而且你可以有选择地看）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.pixelbeat.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pádraig Brady&lt;/a&gt;建议我链接到Ulrich Drepper一篇&lt;a href=&quot;https://www.akkadia.org/drepper/cpumemory.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于内存的的文章&lt;/a&gt;，写的非常的好。我一直在等待有一篇（当然越多越好）关于内存的博文可以链接这篇文章，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇博文翻译自&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot;&gt;Gustavo Duarte&lt;/a&gt;博客上的一篇博文，笔者出于兴趣，同时也是学习，翻译过来，原文： &lt;a href=&quot;http://duartes.org/gustavo/blog/post/motherboard-chipsets-memory-map/&quot;&gt;Motherboard Chipsets and the Memory Map&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了阐明现在操作系统内核如何工作，我打算写一些关于计算机内部实现原理的文章。希望对那些对这方面有兴趣但是却没有经验的电脑爱好者和程序员们有所帮助。计算机的内部实现是我的一个爱好，因此我们主要关注点在Linux、Windows操作系统以及Intel处理器。这篇博文主要讲述了基于Intel处理器的主板布局，CPU怎么样访问内存以及系统内存映射。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Arch" scheme="http://dupengchuan.github.io/tags/Arch/"/>
    
  </entry>
  
  <entry>
    <title>SSH远程登录</title>
    <link href="http://dupengchuan.github.io/2016/05/30/ssh-login/"/>
    <id>http://dupengchuan.github.io/2016/05/30/ssh-login/</id>
    <published>2016-05-30T04:22:52.000Z</published>
    <updated>2016-05-30T10:15:04.528Z</updated>
    
    <content type="html">&lt;p&gt;SSH为Secure Shell的缩写，是位于传输层与应用程序之间的安全传输协议，能够保证信道的安全性。SSH在*uix上的一个重要应用就是远程登录。&lt;/p&gt;
&lt;p&gt;SSH提供了两种验证方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于口令的安全验证，知道账号和口令，输入口令可以登录到远程主机，但是每次登陆都需要输入口令，无法避免“中间人”攻击。&lt;/li&gt;
&lt;li&gt;基于密钥的安全验证，客户机需要有自己的一对密钥，把公钥放在需要访问的服务服务器上。通过使用ssh-agent和ssh-add可以做到免口令登陆。&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;基于口令的安全验证&quot;&gt;&lt;a href=&quot;#基于口令的安全验证&quot; class=&quot;headerlink&quot; title=&quot;基于口令的安全验证&quot;&gt;&lt;/a&gt;基于口令的安全验证&lt;/h1&gt;&lt;p&gt;当发送一个登陆命令时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh user@host
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;查询$HOME/.ssh/known_host里面是否有host对应的公钥&lt;/li&gt;
&lt;li&gt;如果找到host对应的公钥，不会有是否连接远程主机的提示，客户端用公钥加密口令发功给远程主机，远程主机解密，如果口令正确则登陆成功&lt;/li&gt;
&lt;li&gt;如果没有找到host对应的公钥，则向host请求公钥，之后登陆界面会显示远程主机的指纹，是否连接&lt;/li&gt;
&lt;li&gt;如果yes，则执行步骤2，并将远程主机公钥存入$HOME/.ssh/known_host文件中，供下次使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;流程图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/uWUDtGxI3xhg_EE_W3cpVg==/6631698885372855341.png&quot; alt=&quot;sorry&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;基于密钥的安全验证&quot;&gt;&lt;a href=&quot;#基于密钥的安全验证&quot; class=&quot;headerlink&quot; title=&quot;基于密钥的安全验证&quot;&gt;&lt;/a&gt;基于密钥的安全验证&lt;/h1&gt;&lt;p&gt;验证过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;local host将自己的公钥发送给remote host。&lt;/li&gt;
&lt;li&gt;remote host查询自己的authorized_keys文件，如果存在该公钥则给local host 发送一个chanllenge(用local host的公钥加密一个随机数)。&lt;/li&gt;
&lt;li&gt;local host使用自己的私钥加密这个随机数发送给remote&lt;/li&gt;
&lt;li&gt;remote检查随机数，确定验证公钥的合法性，给local host反馈结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img0.ph.126.net/nfQy6oBEaoTDnhcFBO8qZQ==/1993687260144251892.png&quot; alt=&quot;sorry&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;基于密钥验证登录实践&quot;&gt;&lt;a href=&quot;#基于密钥验证登录实践&quot; class=&quot;headerlink&quot; title=&quot;基于密钥验证登录实践&quot;&gt;&lt;/a&gt;基于密钥验证登录实践&lt;/h1&gt;&lt;p&gt;步骤很简单&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成本地公私钥对&lt;/li&gt;
&lt;li&gt;本地公钥添加到remot的$HOME/.ssh/authorized_keys文件中&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;本地生成密钥对&quot;&gt;&lt;a href=&quot;#本地生成密钥对&quot; class=&quot;headerlink&quot; title=&quot;本地生成密钥对&quot;&gt;&lt;/a&gt;本地生成密钥对&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以为自己的私钥设置口令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -P &amp;quot;xxxx&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自己的私钥设置口令之后每次登陆都需要输入自己的口令，使用ssh-agent和ssh-add可以做到把口令的放入代理不用自己每次输入。&lt;/p&gt;
&lt;h2 id=&quot;添加公钥到remote&quot;&gt;&lt;a href=&quot;#添加公钥到remote&quot; class=&quot;headerlink&quot; title=&quot;添加公钥到remote&quot;&gt;&lt;/a&gt;添加公钥到remote&lt;/h2&gt;&lt;p&gt;方法1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ssh-copy-id user@host
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;tips:&lt;/p&gt;
&lt;p&gt;远程配置文件/etc/ssd/sshd_config去掉以下注释，然后重启ssh服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#RSAAuthentication yes
#PublickeyAuthentication yes
#AuthorizedKeyFile .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh user@host &amp;apos;mkdir -p .ssh &amp;amp;&amp;amp; cat &amp;gt;&amp;gt; .ssh/authorized_keys&amp;apos; &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法3&lt;/p&gt;
&lt;p&gt;  scp id_rsa.pub user@host:.ssh/&lt;br&gt;  cat id_rsa.pub &amp;gt;&amp;gt; authorized_keys&lt;/p&gt;
&lt;h2 id=&quot;设置免口令登陆&quot;&gt;&lt;a href=&quot;#设置免口令登陆&quot; class=&quot;headerlink&quot; title=&quot;设置免口令登陆&quot;&gt;&lt;/a&gt;设置免口令登陆&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ssh-add $HOME/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 输入自己的口令，之后登陆就交给代理处理，不需要输入口令&lt;/p&gt;
&lt;p&gt;遇到的问题：&lt;/p&gt;
&lt;p&gt;Could not open a connection to your authentication agent&lt;/p&gt;
&lt;p&gt;通过下面命令解决了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-agent bash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不用之后一定要清除，否则别人用你的电脑一样可以免口令登陆&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-agent -k
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看私钥指纹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-add -l
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;权限问题可能会造成不是自己想要的结果，比如id_rsa文件group和other如果有了写权限，基于密钥的验证就会降级为基于口令,设置.ssh目录的最小权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod 700 .ssh
chmod 600 .ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SSH总的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.ph.126.net/2wPg2IDX5YSLWin_EGsRJw==/6631745064861226711.jpg&quot; alt=&quot;sorry&quot;&gt;&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSH原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://7056824.blog.51cto.com/69854/403669/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用ssh公钥密钥自动登陆linux服务器&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;SSH为Secure Shell的缩写，是位于传输层与应用程序之间的安全传输协议，能够保证信道的安全性。SSH在*uix上的一个重要应用就是远程登录。&lt;/p&gt;
&lt;p&gt;SSH提供了两种验证方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于口令的安全验证，知道账号和口令，输入口令可以登录到远程主机，但是每次登陆都需要输入口令，无法避免“中间人”攻击。&lt;/li&gt;
&lt;li&gt;基于密钥的安全验证，客户机需要有自己的一对密钥，把公钥放在需要访问的服务服务器上。通过使用ssh-agent和ssh-add可以做到免口令登陆。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="http://dupengchuan.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Bash中的快捷键</title>
    <link href="http://dupengchuan.github.io/2016/05/29/bash-shortcuts/"/>
    <id>http://dupengchuan.github.io/2016/05/29/bash-shortcuts/</id>
    <published>2016-05-29T11:43:28.000Z</published>
    <updated>2016-05-30T04:23:23.556Z</updated>
    
    <content type="html">&lt;p&gt;生活在shell bash上的人熟记Bash中快捷键可以大大提高敲命令和查看的速度，提高工作的效率。在这人力记一下笔者常用的一些快捷键。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; class=&quot;headerlink&quot; title=&quot;光标移动&quot;&gt;&lt;/a&gt;光标移动&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + 左箭头&lt;/td&gt;
&lt;td&gt;向左移动一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + 右箭头&lt;/td&gt;
&lt;td&gt;向右移动一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + a&lt;/td&gt;
&lt;td&gt;移动到行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + e&lt;/td&gt;
&lt;td&gt;移动到行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;编辑操作&quot;&gt;&lt;a href=&quot;#编辑操作&quot; class=&quot;headerlink&quot; title=&quot;编辑操作&quot;&gt;&lt;/a&gt;编辑操作&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + u&lt;/td&gt;
&lt;td&gt;清除光标左边所有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + k&lt;/td&gt;
&lt;td&gt;清除光标右边所有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + d&lt;/td&gt;
&lt;td&gt;从光标位置开始删除到单词尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + w&lt;/td&gt;
&lt;td&gt;从光标位置开始删除到单词首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + r&lt;/td&gt;
&lt;td&gt;搜索历史命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + .&lt;/td&gt;
&lt;td&gt;使用上一次命令最后一个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + c&lt;/td&gt;
&lt;td&gt;拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + v&lt;/td&gt;
&lt;td&gt;粘贴&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;控制操作&quot;&gt;&lt;a href=&quot;#控制操作&quot; class=&quot;headerlink&quot; title=&quot;控制操作&quot;&gt;&lt;/a&gt;控制操作&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + l&lt;/td&gt;
&lt;td&gt;清屏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + PgUP&lt;/td&gt;
&lt;td&gt;向上翻页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + PgDn&lt;/td&gt;
&lt;td&gt;向下翻页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + s&lt;/td&gt;
&lt;td&gt;阻止屏幕输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + q&lt;/td&gt;
&lt;td&gt;允许屏幕输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + z&lt;/td&gt;
&lt;td&gt;挂起进程(之后进程处于T状态)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;生活在shell bash上的人熟记Bash中快捷键可以大大提高敲命令和查看的速度，提高工作的效率。在这人力记一下笔者常用的一些快捷键。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="http://dupengchuan.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell流程控制语句学习</title>
    <link href="http://dupengchuan.github.io/2016/05/29/shell-grammar/"/>
    <id>http://dupengchuan.github.io/2016/05/29/shell-grammar/</id>
    <published>2016-05-29T01:44:21.000Z</published>
    <updated>2016-05-29T04:47:35.172Z</updated>
    
    <content type="html">&lt;p&gt;本博文主要讲述Shell *sh 的流程控制语句,主要有分支语句和循环语句，分支语句包括if、case。循环语句有for、while、until。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;分支语句&quot;&gt;&lt;a href=&quot;#分支语句&quot; class=&quot;headerlink&quot; title=&quot;分支语句&quot;&gt;&lt;/a&gt;分支语句&lt;/h1&gt;&lt;h2 id=&quot;if-语句&quot;&gt;&lt;a href=&quot;#if-语句&quot; class=&quot;headerlink&quot; title=&quot;if 语句&quot;&gt;&lt;/a&gt;if 语句&lt;/h2&gt;&lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if cond1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;elif cond2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tips:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;else 之后没有 then 命令&lt;/li&gt;
&lt;li&gt;最后一定要用 fi 结束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些是语法上的强制要求，违反就会运行报错&lt;/p&gt;
&lt;h2 id=&quot;case语句&quot;&gt;&lt;a href=&quot;#case语句&quot; class=&quot;headerlink&quot; title=&quot;case语句&quot;&gt;&lt;/a&gt;case语句&lt;/h2&gt;&lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;case $value in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;regex1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;... #多个case&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;esac&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tip:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最后一个case可加可不加;;,其他case最后必须有;;命令&lt;/li&gt;
&lt;li&gt;最后必须要有 esac 结束命令&lt;/li&gt;
&lt;li&gt;匹配条件可以有多个，用 | 并列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;匹配规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;任意多个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;? 单个字符&lt;/li&gt;
&lt;li&gt;[] 在[]里面的任意单个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Demo&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;case $1 in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1|2|3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo &amp;quot;input: &amp;quot; $1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4?)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo &amp;quot;input: &amp;quot; 40~49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[a-z]|[A-Z]j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo &amp;quot;input: letter&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo &amp;quot;any&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;esac&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;循环语句&quot;&gt;&lt;a href=&quot;#循环语句&quot; class=&quot;headerlink&quot; title=&quot;循环语句&quot;&gt;&lt;/a&gt;循环语句&lt;/h1&gt;&lt;h2 id=&quot;for语句&quot;&gt;&lt;a href=&quot;#for语句&quot; class=&quot;headerlink&quot; title=&quot;for语句&quot;&gt;&lt;/a&gt;for语句&lt;/h2&gt;&lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for i in $(seq start end)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;notes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环变量和起始和结束变量都没有带 $ 符号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Demo&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for i in $(seq 0 10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo hello world!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;while语句&quot;&gt;&lt;a href=&quot;#while语句&quot; class=&quot;headerlink&quot; title=&quot;while语句&quot;&gt;&lt;/a&gt;while语句&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;while condition&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Demo&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;read i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;declare -i target=10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while ((i&amp;lt;target))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    echo $i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let i++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;until语句&quot;&gt;&lt;a href=&quot;#until语句&quot; class=&quot;headerlink&quot; title=&quot;until语句&quot;&gt;&lt;/a&gt;until语句&lt;/h2&gt;&lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;until condition&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tips:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件为假的时候执行循环&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Demo&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;read i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;declare -i target=10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;until ((i &amp;gt; target))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo $1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ((i++))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;和c语言比较,关键字条件之间必须有空格&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本博文主要讲述Shell *sh 的流程控制语句,主要有分支语句和循环语句，分支语句包括if、case。循环语句有for、while、until。&lt;br&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="http://dupengchuan.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>安装Scrapy</title>
    <link href="http://dupengchuan.github.io/2016/05/27/scrapy-setup/"/>
    <id>http://dupengchuan.github.io/2016/05/27/scrapy-setup/</id>
    <published>2016-05-27T13:45:36.000Z</published>
    <updated>2016-05-28T07:54:38.975Z</updated>
    
    <content type="html">&lt;h1 id=&quot;安装python环境&quot;&gt;&lt;a href=&quot;#安装python环境&quot; class=&quot;headerlink&quot; title=&quot;安装python环境&quot;&gt;&lt;/a&gt;安装python环境&lt;/h1&gt;&lt;p&gt;下载&lt;a href=&quot;https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;python 2.7.11&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf Python-2.7.11.tgz

cd Python-2.7.11

./configure --prefix=/usr/local

make &amp;amp;&amp;amp; make all &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;安装setuptools&quot;&gt;&lt;a href=&quot;#安装setuptools&quot; class=&quot;headerlink&quot; title=&quot;安装setuptools&quot;&gt;&lt;/a&gt;安装setuptools&lt;/h1&gt;&lt;p&gt;使用&lt;a href=&quot;bootstrap.pypa.io&quot;&gt;ez_setup.py&lt;/a&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget --no-check-certificate https://bootstrap.pypa.io/ez_setup.py

python ez_setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;安装pip&quot;&gt;&lt;a href=&quot;#安装pip&quot; class=&quot;headerlink&quot; title=&quot;安装pip&quot;&gt;&lt;/a&gt;安装pip&lt;/h1&gt;&lt;p&gt;使用&lt;a href=&quot;bootstrap.pypa.io&quot;&gt;get-pip.py&lt;/a&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget --no-check-certificate https://bootstrap.pypa.io/get-pip.py

python get-pip.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用该方法会自动安装 setuptools 和 wheel&lt;/p&gt;
&lt;p&gt;使用安装包： &lt;a href=&quot;https://pypi.python.org/pypi/pip/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pip-8.1.2&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf pip-8.1.2.tar.gz

cd pip-8.1.2

python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用此方法安装必须先安装好setuptools&lt;/p&gt;
&lt;h1 id=&quot;安装Scrapy&quot;&gt;&lt;a href=&quot;#安装Scrapy&quot; class=&quot;headerlink&quot; title=&quot;安装Scrapy&quot;&gt;&lt;/a&gt;安装Scrapy&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;pip install Scrapy
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;遇到的问题： Failed building wheel for cryptography&lt;/p&gt;
&lt;p&gt;cryptography安装不成功，这个包是有关https使用的，系统中要有支持的库，看到了这里&lt;a href=&quot;http://stackoverflow.com/questions/22073516/failed-to-install-python-cryptography-package-with-pip-and-setup-py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;,里面通过安装以下包解决了问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo yum install gcc libffi-devel python-devel openssl-devel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用rpm命令，检查发现缺少了libffi-devel&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install libffi-devel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装之后顺利安装完成Scrapy&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cat &amp;gt; myspider.py &amp;lt;&amp;lt;EOF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  from scrapy import Spider, Item, Field&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  class Post(Item):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    title = Field()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  class BlogSpider(Spider):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = &#39;kevin&#39;blog&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    start_urls = [&#39;dupengchuan.me&#39;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def parse(self, response):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return [Post(title=e.extract()) for e in response.css(&quot;h2 a::text&quot;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EOF&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scrap runspider myspider
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行结果正常这里不再显示&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;OS： CentOS 6.5&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装python环境&quot;&gt;&lt;a href=&quot;#安装python环境&quot; class=&quot;headerlink&quot; title=&quot;安装python环境&quot;&gt;&lt;/a&gt;安装python环境&lt;/h1&gt;&lt;p&gt;下载&lt;a href=&quot;https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz&quot;&gt;python 2.7.11&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf Python-2.7.11.tgz

cd Python-2.7.11

./configure --prefix=/usr/local

make &amp;amp;&amp;amp; make all &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://dupengchuan.github.io/tags/Python/"/>
    
      <category term="Crawler" scheme="http://dupengchuan.github.io/tags/Crawler/"/>
    
  </entry>
  
  <entry>
    <title>FTP服务器安装以及配置</title>
    <link href="http://dupengchuan.github.io/2016/05/27/vsftpd/"/>
    <id>http://dupengchuan.github.io/2016/05/27/vsftpd/</id>
    <published>2016-05-27T10:41:18.000Z</published>
    <updated>2016-05-28T03:47:22.718Z</updated>
    
    <content type="html">&lt;p&gt;今天安装了一下FTP服务器，记录一下安装过程，以及遇到的问题&lt;/p&gt;
&lt;p&gt;OS： CentOS6.5&lt;/p&gt;
&lt;p&gt;vsftpd Version： 2.2.2&lt;/p&gt;
&lt;h1 id=&quot;安装vsftpd&quot;&gt;&lt;a href=&quot;#安装vsftpd&quot; class=&quot;headerlink&quot; title=&quot;安装vsftpd&quot;&gt;&lt;/a&gt;安装vsftpd&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;yum install vsftpd
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;p&gt;vaftpd的配置文件：/etc/vsftpd/vsftpd.conf&lt;/p&gt;
&lt;p&gt;关掉匿名登录开启本地用户登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;anonimous_enable=NO

local_enable=YES
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;设置开机启动&quot;&gt;&lt;a href=&quot;#设置开机启动&quot; class=&quot;headerlink&quot; title=&quot;设置开机启动&quot;&gt;&lt;/a&gt;设置开机启动&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用可交互的界面设置（空格选中）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ntsysv
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chkconfig vsftpd on   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;启动vsftpd&quot;&gt;&lt;a href=&quot;#启动vsftpd&quot; class=&quot;headerlink&quot; title=&quot;启动vsftpd&quot;&gt;&lt;/a&gt;启动vsftpd&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;service vsftpd start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现不能访问，可以ping通，说明不是网络的问题，telnet ip 21。telnet不上,应该是防火墙的原因&lt;/p&gt;
&lt;h1 id=&quot;配置防火墙&quot;&gt;&lt;a href=&quot;#配置防火墙&quot; class=&quot;headerlink&quot; title=&quot;配置防火墙&quot;&gt;&lt;/a&gt;配置防火墙&lt;/h1&gt;&lt;p&gt;allow all ftp incoming connections&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p tcp --dport 21 -m state --state ESTABLISHED -j ACCEPT

iptables -A OUTPUT -p tcp --sport 21 -m state --state NEW,ESTABLISHED -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Enable active ftp transfers&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p tcp --dport 20 -m state --state ESTABLISHED,RELATED -j ACCEPT

iptables -A OUTPUT -p tcp --sport 20 -m state --state ESTABLISHED -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Enable passive ftp transfers&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p tcp --sport 1024:65535 --dport 1024:65535 -m state --state ESTABLISHED -j ACCEPT

iptables -A OUTPUT -p tcp --sport 1024:65535 --dport 1024:65535 -m state --state ESTABLISHED,RELATED -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主动模式中，使用端口20发送数据，所以是对20端口配置&lt;/p&gt;
&lt;p&gt;被动模式的端口号是动态申请的，所以指定的是一个范围&lt;/p&gt;
&lt;p&gt;防火墙配置好之后记得保存规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service iptables save
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启服务，发现还是不能登录，报错如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;500 OOPS: cannot change directory:/home/*******

500 OOPS: child died
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个权限的问题，google一下，发现是SELinux做了约束，需要修改相应配置&lt;/p&gt;
&lt;h1 id=&quot;修改SELinux&quot;&gt;&lt;a href=&quot;#修改SELinux&quot; class=&quot;headerlink&quot; title=&quot;修改SELinux&quot;&gt;&lt;/a&gt;修改SELinux&lt;/h1&gt;&lt;p&gt;方法一、关闭SELinux&lt;/p&gt;
&lt;p&gt;SELinux的启动配置文件是： /etc/selinux/config&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELINUX=disabled
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法二、开启某些功能&lt;/p&gt;
&lt;p&gt;网上有的人这么做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setsebool -P ftpd_disable_trans on
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是我这里找不到 ftpd_disable_trans，可能是系统版本的问题，经过尝试，终于用下面命令搞定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setsebool -P ftp_home_dir on
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;一些关于SELinux的命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setsebool xxx on/off　　＃设置状态

getsetools -a　　＃结合grep可以看到有关ftp的约束

sestatus　　＃查看selinux是否开启
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;今天安装了一下FTP服务器，记录一下安装过程，以及遇到的问题&lt;/p&gt;
&lt;p&gt;OS： CentOS6.5&lt;/p&gt;
&lt;p&gt;vsftpd Version： 2.2.2&lt;/p&gt;
&lt;h1 id=&quot;安装vsftpd&quot;&gt;&lt;a href=&quot;#安装vsftpd&quot; class=&quot;headerlink&quot; title=&quot;安装vsftpd&quot;&gt;&lt;/a&gt;安装vsftpd&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;yum install vsftpd
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://dupengchuan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>你的操作系统是如何运行的？</title>
    <link href="http://dupengchuan.github.io/2016/05/24/when-dos-your-os-run/"/>
    <id>http://dupengchuan.github.io/2016/05/24/when-dos-your-os-run/</id>
    <published>2016-05-24T05:37:08.000Z</published>
    <updated>2016-05-26T15:19:40.795Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;这篇博文来自于&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gustavo Duarte&lt;/a&gt;的科普博客，本人出于兴趣翻译过来，原文：&lt;a href=&quot;http://duartes.org/gustavo/blog/post/when-does-your-os-run/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;When Does Your OS Run?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里有一个问题，就是在你阅读到我这篇博文中的这句话的时候，你的操作系统是否正在运行？还是只有浏览器在运行？还是它们都处于空闲状态，正在等待你分配任务？&lt;/p&gt;
&lt;p&gt;这些问题虽然简单但却深入到整个软件运行过程。为了准确地回答这些问题，我们要在大脑中对操作系统行为有一个良好的运行状态模型，即操作系统依次通知进程执行，安全方面以及故障的决策。希望通过这一些列博文，我们能够在脑海里建立起这种模型。本文主要使用Linux作为主要的操作系统，OS X和Windows也会偶尔出现。某些地方我会附上源码链接以方便那些想要深入研究的人。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有一个基本公理：即在任何时刻，在CPU上有且仅有一个任务在运行。这个任务通常是一个进程，像浏览器，音乐播放器等等，但是也有可能是操作系统线程，但它也是一个任务。同一时刻CPU上的任务不可能是两个或者多个，也不会是0个。&lt;/p&gt;
&lt;p&gt;这个听起来很抽象，举个例子，如果你的音乐播放器一直占用着CPU,并且不让其他任务占有，这种情况，你不能打开一个工具（Windows是任务管理器，Linux使用shell命令）去杀死它，此时移动或者点击鼠标都是无效的，因为操作系统不会让它们执行，那么你可能被一直卡在”The fox”（一首歌的名字）。&lt;/p&gt;
&lt;p&gt;以上便是中断的由来。就像神经系统打断大脑的正常运行，带来外界的刺激，一声巨响或者拍一下肩膀。主板上的&lt;a href=&quot;http://duartes.org/gustavo/blog/post/motherboard-chipsets-memory-map&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;芯片&lt;/a&gt;为了传达外部事件（按下键盘，网络数据包到达，硬盘读取完毕等等）也会中断CPU。硬件外设、中断控制器以及CPU一起完成中断过程。&lt;/p&gt;
&lt;p&gt;控制任务执行时间是通过中断实现的。在&lt;a href=&quot;http://duartes.org/gustavo/blog/post/kernel-boot-process&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;系统启动过程&lt;/a&gt;中，内核启动一个定时器周期性的发出中断请求，比如10ms一次。当一个中断发生后，CPU执行中断处理程序，更新系统的状态，观察一些事件，比如是否当前进程执行时间超过了时间片？TCP连接是否超时？中断给了内核一个机会思考这些问题并采取合适方法去解决。这就像你设置了定时报警器，特定的时间点回去提醒你去做什么事情：我现在应该做什么？是否有更重要的事情做？&lt;/p&gt;
&lt;p&gt;内核通过中断周期性地占有CPU,中断使操作系统像时钟一样滴答滴答地运行。但中断不止这些，中断也用来处理一些软件事件，比如整数溢出和缺页错误，这些中断没有外部硬件的参与。中断是进入系统内核最重要和最频繁的入口，因此很多电子工程师对中断作为操作系统运行的机制表示担心。&lt;/p&gt;
&lt;p&gt;不说废话了，让我们来一些实际行动。下面是一个基于英特尔酷睿i5的网卡中断过程。现在该图有链接，点击获得更多信息。例如从设备到它的linux驱动。(ps：原文里面的图片有链接)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.ph.126.net/mZPBFG0B6_SQ9BV1_veMxQ==/61924494977343331.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们来看看这张图。首先，由于有很多中断源，如果硬件只是告诉CPU:“嗨，有事情发生了！”，然后离开，那么CPU不知道发生了什么，显然这不会有多大的实际意义。因此每个设备都被安排了一个中断请求路线(LRQ)。所有的中断请求都会到达中断请求控制器，中断请求控制器根据LRQ依次将中断请求映射为中断向量（0-255表示）。当中断到达CPU,CPU面对的是一个友好的明确的中断向量。而不是各种各样的外部硬件。&lt;/p&gt;
&lt;p&gt;反过来，CPU有一个指向255个函数数组的指针，这些函数被内核支持，每一个函数对应一个特定的中断向量。在后面我们将会看到这个数组——中断描述符表（IDT）。&lt;/p&gt;
&lt;p&gt;每当一个中断到达，CPU使用它的中断向量作为索引进入IDT然后运行相应的中断处理函数。这是一个特殊的函数调用，因为发生在当前运行任务的上下文，操作系统以最小的开销去响应外部事件。因此web服务器如果在向你发送数据的时候调用一个函数，这是不是很酷或者很可怕？下面我们展示一个场景：CPU正在运行一个Vim命令时，来了一个中断。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img0.ph.126.net/u-7hwJNC-174Sx4O1zkXJw==/1156299204428848479.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意中断的到来如何导致内核模式和&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ring 0&lt;/a&gt;的切换，但是不会改变活动任务。这就好像Vim变魔术一般调用一个函数直接进入内核。但是Vim依然在这里，它的&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;地址空间&lt;/a&gt;没有变，正在等待函数返回。&lt;/p&gt;
&lt;p&gt;终于要写完了，兴奋的时刻！，哈哈，我知道我还没有回答那个开放问题，并且还引入了新问题。但是当你读到我这句话的时候，如果你仍旧怀疑操作系统到底是什么状态。相信你可以找到答案,因为我们之前已经讲解了了操作系统的动态运行模型。这个浏览器的问题也变得清晰了。如果你还有问题，尤其是这个博文发表之后，我会尽快在博文里面或者评论里面回答你的问题。之后的会在RSS和Twitter上做解答。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇博文来自于&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot;&gt;Gustavo Duarte&lt;/a&gt;的科普博客，本人出于兴趣翻译过来，原文：&lt;a href=&quot;http://duartes.org/gustavo/blog/post/when-does-your-os-run/&quot;&gt;When Does Your OS Run?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里有一个问题，就是在你阅读到我这篇博文中的这句话的时候，你的操作系统是否正在运行？还是只有浏览器在运行？还是它们都处于空闲状态，正在等待你分配任务？&lt;/p&gt;
&lt;p&gt;这些问题虽然简单但却深入到整个软件运行过程。为了准确地回答这些问题，我们要在大脑中对操作系统行为有一个良好的运行状态模型，即操作系统依次通知进程执行，安全方面以及故障的决策。希望通过这一些列博文，我们能够在脑海里建立起这种模型。本文主要使用Linux作为主要的操作系统，OS X和Windows也会偶尔出现。某些地方我会附上源码链接以方便那些想要深入研究的人。&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://dupengchuan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://dupengchuan.github.io/2016/05/22/hello-world/"/>
    <id>http://dupengchuan.github.io/2016/05/22/hello-world/</id>
    <published>2016-05-22T05:18:13.523Z</published>
    <updated>2016-05-26T15:21:23.015Z</updated>
    
    <content type="html">&lt;p&gt;很早就想有一个自己的博客，今天终于初步搭建好了。&lt;/p&gt;
&lt;p&gt;使用的是github pages托管网页,一个静态博客。&lt;/p&gt;
&lt;p&gt;Hexo静态网页生成工具,有关Hexo的使用可以从官网获得帮助：&lt;a href=&quot;http://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hexo.io&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;主题使用的是even，连接：&lt;a href=&quot;https://github.com/ahonn/hexo-theme-even&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ahonn/hexo-theme-even&lt;/a&gt;，在此谢谢ahonn。&lt;/p&gt;
&lt;p&gt;争取以后养成写博客的习惯&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n1.itc.cn/img8/wb/smccloud/recom/2015/09/06/144154649059751427.JPEG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;很早就想有一个自己的博客，今天终于初步搭建好了。&lt;/p&gt;
&lt;p&gt;使用的是github pages托管网页,一个静态博客。&lt;/p&gt;
&lt;p&gt;Hexo静态网页生成工具,有关Hexo的使用可以从官网获得帮助：&lt;a href=&quot;http://hexo.io&quot;&gt;http://hexo.io&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="http://dupengchuan.github.io/tags/life/"/>
    
  </entry>
  
</feed>
