<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin&#39; blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dupengchuan.github.io/"/>
  <updated>2016-06-23T13:10:02.939Z</updated>
  <id>http://dupengchuan.github.io/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis安装与配置</title>
    <link href="http://dupengchuan.github.io/2016/06/23/redis-study/"/>
    <id>http://dupengchuan.github.io/2016/06/23/redis-study/</id>
    <published>2016-06-23T11:42:15.000Z</published>
    <updated>2016-06-23T13:10:02.939Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h1&gt;&lt;p&gt;Redis 是一款完全开源免费的，遵守BSD协议，具有高性能的key-value数据库。Redis 与其他 key - value 缓存产品有以下三个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Redis优势&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。&lt;/li&gt;
&lt;li&gt;丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。&lt;/li&gt;
&lt;li&gt;原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。&lt;br&gt;丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Redis安装&quot;&gt;&lt;a href=&quot;#Redis安装&quot; class=&quot;headerlink&quot; title=&quot;Redis安装&quot;&gt;&lt;/a&gt;Redis安装&lt;/h1&gt;&lt;p&gt;Linux环境下安装(CentOS6.5)：&lt;/p&gt;
&lt;p&gt;redis官网： &lt;a href=&quot;http://redis.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://redis.io&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ wget http://download.redis.io/releases/redis-3.2.1.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ tar xzf redis-3.2.1.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd redis-3.2.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ make&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下,下面启动redis服务:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ src/redis-server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd src
$ ./redis-server redis.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cd src&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ./redis-cli&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;redis&amp;gt; set foo bar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;redis&amp;gt; get foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;Redis配置&quot;&gt;&lt;a href=&quot;#Redis配置&quot; class=&quot;headerlink&quot; title=&quot;Redis配置&quot;&gt;&lt;/a&gt;Redis配置&lt;/h1&gt;&lt;p&gt;Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。可以通过 config 命令查看或设置配置项。&lt;/p&gt;
&lt;h2 id=&quot;获取配置信息&quot;&gt;&lt;a href=&quot;#获取配置信息&quot; class=&quot;headerlink&quot; title=&quot;获取配置信息&quot;&gt;&lt;/a&gt;获取配置信息&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;redis 127.0.0.1&amp;gt;config get 配置项
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取日志级别：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis 127.0.0.1&amp;gt;config get loglevel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取所有配置信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis 127.0.0.1&amp;gt;config get *
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;设置配置信息&quot;&gt;&lt;a href=&quot;#设置配置信息&quot; class=&quot;headerlink&quot; title=&quot;设置配置信息&quot;&gt;&lt;/a&gt;设置配置信息&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;redis 127.0.0.1&amp;gt;config set 配置项 值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实例：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;CONFIG&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;loglevel&lt;/span&gt; &quot;&lt;span class=&quot;selector-tag&quot;&gt;notice&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;CONFIG&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;loglevel&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1) &quot;&lt;span class=&quot;selector-tag&quot;&gt;loglevel&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2) &quot;&lt;span class=&quot;selector-tag&quot;&gt;notice&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然也可以通过直接修改redis.conf来实现&lt;/p&gt;
&lt;h2 id=&quot;参数说明&quot;&gt;&lt;a href=&quot;#参数说明&quot; class=&quot;headerlink&quot; title=&quot;参数说明&quot;&gt;&lt;/a&gt;参数说明&lt;/h2&gt;&lt;p&gt;redis.conf 配置项说明如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程&lt;br&gt; daemonize no&lt;/li&gt;
&lt;li&gt;当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定&lt;br&gt; pidfile /var/run/redis.pid&lt;/li&gt;
&lt;li&gt;指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字&lt;br&gt; port 6379&lt;/li&gt;
&lt;li&gt;绑定的主机地址&lt;br&gt; bind 127.0.0.1&lt;/li&gt;
&lt;li&gt;当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能&lt;br&gt; timeout 300&lt;/li&gt;
&lt;li&gt;指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose&lt;br&gt; loglevel verbose&lt;/li&gt;
&lt;li&gt;日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null&lt;br&gt; logfile stdout&lt;/li&gt;
&lt;li&gt;设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id&lt;br&gt; databases 16&lt;/dbid&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合&lt;br&gt; save &lt;seconds&gt; &lt;changes&gt;&lt;br&gt; Redis默认配置文件中提供了三个条件：&lt;br&gt; save 900 1&lt;br&gt; save 300 10&lt;br&gt; save 60 10000&lt;br&gt; 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。&lt;/changes&gt;&lt;/seconds&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大&lt;br&gt;rdbcompression yes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;指定本地数据库文件名，默认值为dump.rdb&lt;br&gt;dbfilename dump.rdb&lt;/li&gt;
&lt;li&gt;指定本地数据库存放目录&lt;br&gt;dir ./&lt;/li&gt;
&lt;li&gt;设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步&lt;br&gt;slaveof &lt;masterip&gt; &lt;masterport&gt;&lt;/masterport&gt;&lt;/masterip&gt;&lt;/li&gt;
&lt;li&gt;当master服务设置了密码保护时，slav服务连接master的密码&lt;br&gt;masterauth &lt;master-password&gt;&lt;/master-password&gt;&lt;/li&gt;
&lt;li&gt;设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭&lt;br&gt;requirepass foobared&lt;/password&gt;&lt;/li&gt;
&lt;li&gt;设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息&lt;br&gt;maxclients 128&lt;/li&gt;
&lt;li&gt;指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区&lt;br&gt;maxmemory &lt;bytes&gt;&lt;/bytes&gt;&lt;/li&gt;
&lt;li&gt;指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no&lt;br&gt;appendonly no&lt;/li&gt;
&lt;li&gt;指定更新日志文件名，默认为appendonly.aof&lt;br&gt; appendfilename appendonly.aof&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定更新日志条件，共有3个可选值：&lt;br&gt;no：表示等操作系统进行数据缓存同步到磁盘（快）&lt;br&gt;always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）&lt;br&gt;everysec：表示每秒同步一次（折衷，默认值）&lt;br&gt;appendfsync everysec&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）&lt;br&gt; vm-enabled no&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享&lt;br&gt; vm-swap-file /tmp/redis.swap&lt;/li&gt;
&lt;li&gt;将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0&lt;br&gt; vm-max-memory 0&lt;/li&gt;
&lt;li&gt;Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值&lt;br&gt; vm-page-size 32&lt;/li&gt;
&lt;li&gt;设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。&lt;br&gt; vm-pages 134217728&lt;/li&gt;
&lt;li&gt;设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4&lt;br&gt; vm-max-threads 4&lt;/li&gt;
&lt;li&gt;设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启&lt;br&gt;glueoutputbuf yes&lt;/li&gt;
&lt;li&gt;指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法&lt;br&gt;hash-max-zipmap-entries 64&lt;br&gt;hash-max-zipmap-value 512&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）&lt;br&gt;activerehashing yes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件include/path/to/local.conf&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Redis数据类型&quot;&gt;&lt;a href=&quot;#Redis数据类型&quot; class=&quot;headerlink&quot; title=&quot;Redis数据类型&quot;&gt;&lt;/a&gt;Redis数据类型&lt;/h1&gt;&lt;p&gt;Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。&lt;/p&gt;
&lt;h2 id=&quot;String（字符串）&quot;&gt;&lt;a href=&quot;#String（字符串）&quot; class=&quot;headerlink&quot; title=&quot;String（字符串）&quot;&gt;&lt;/a&gt;String（字符串）&lt;/h2&gt;&lt;p&gt;string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个键最大能存储&lt;em&gt;512MB&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;实例&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;name&lt;/span&gt; &quot;&lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;&lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 name，对应的值为w3cschool.cc。&lt;/p&gt;
&lt;h2 id=&quot;Hash（哈希）&quot;&gt;&lt;a href=&quot;#Hash（哈希）&quot; class=&quot;headerlink&quot; title=&quot;Hash（哈希）&quot;&gt;&lt;/a&gt;Hash（哈希）&lt;/h2&gt;&lt;p&gt;Redis hash 是一个键值对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。&lt;/p&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;redis 127.0.0.1:6379&amp;gt; hmset user:1 username w3cschool.cc password w3cschool.cc points 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;redis 127.0.0.1:6379&amp;gt; hgetall user:1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1) &amp;quot;username&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2) &amp;quot;w3cschool.cc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3) &amp;quot;password&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4) &amp;quot;w3cschool.cc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5) &amp;quot;points&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6) &amp;quot;200&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;redis 127.0.0.1:6379&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上实例中 hash 数据类型存储了包含用户脚本信息的用户对象。 实例中我们使用了 Redis HMSET, HGETALL 命令，user:1 为键值。每个 hash 可以存储 &lt;em&gt;2&lt;sup&gt;32&lt;/sup&gt; - 1&lt;/em&gt; 键值对（&lt;strong&gt;40多亿&lt;/strong&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;List（列表）&quot;&gt;&lt;a href=&quot;#List（列表）&quot; class=&quot;headerlink&quot; title=&quot;List（列表）&quot;&gt;&lt;/a&gt;List（列表）&lt;/h2&gt;&lt;p&gt;Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。&lt;/p&gt;
&lt;p&gt;实例&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;lpush&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;selector-tag&quot;&gt;integer&lt;/span&gt;) 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;lpush&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;mongodb&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;selector-tag&quot;&gt;integer&lt;/span&gt;) 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;lpush&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;rabitmq&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;selector-tag&quot;&gt;integer&lt;/span&gt;) 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;lrange&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt; 0 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1) &quot;&lt;span class=&quot;selector-tag&quot;&gt;rabitmq&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2) &quot;&lt;span class=&quot;selector-tag&quot;&gt;mongodb&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3) &quot;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;列表最多可存储 2&lt;sup&gt;32&lt;/sup&gt; - 1 元素 (4294967295, 每个列表可存储40多亿)。&lt;/p&gt;
&lt;h2 id=&quot;Set（集合）&quot;&gt;&lt;a href=&quot;#Set（集合）&quot; class=&quot;headerlink&quot; title=&quot;Set（集合）&quot;&gt;&lt;/a&gt;Set（集合）&lt;/h2&gt;&lt;p&gt;Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。sadd 命令添加一个string元素到,key对应的set集合中，成功返回1,如果元素以及在集合中返回0,key对应的set不存在返回错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sadd key member
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实例&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;sadd&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;selector-tag&quot;&gt;integer&lt;/span&gt;) 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;sadd&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;mongodb&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;selector-tag&quot;&gt;integer&lt;/span&gt;) 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;sadd&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;rabitmq&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;selector-tag&quot;&gt;integer&lt;/span&gt;) 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;sadd&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;rabitmq&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;selector-tag&quot;&gt;integer&lt;/span&gt;) 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;smembers&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;w3cschool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1) &quot;&lt;span class=&quot;selector-tag&quot;&gt;rabitmq&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2) &quot;&lt;span class=&quot;selector-tag&quot;&gt;mongodb&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3) &quot;&lt;span class=&quot;selector-tag&quot;&gt;redis&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。&lt;br&gt;集合中最大的成员数为 2&lt;sup&gt;32&lt;/sup&gt; - 1 (4294967295, 每个集合可存储40多亿个成员)。&lt;/p&gt;
&lt;h2 id=&quot;zset-sorted-set：有序集合&quot;&gt;&lt;a href=&quot;#zset-sorted-set：有序集合&quot; class=&quot;headerlink&quot; title=&quot;zset(sorted set：有序集合)&quot;&gt;&lt;/a&gt;zset(sorted set：有序集合)&lt;/h2&gt;&lt;p&gt;Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。&lt;br&gt;zset的成员是唯一的,但分数(score)却可以重复。zadd 命令添加元素到集合，元素在集合中存在则更新对应score&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zadd key score member
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实例&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;redis 127.0.0.1:6379&amp;gt; zadd w3cschool.cc 0 redis&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(integer) 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;redis 127.0.0.1:6379&amp;gt; zadd w3cschool.cc 0 mongodb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(integer) 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;redis 127.0.0.1:6379&amp;gt; zadd w3cschool.cc 0 rabitmq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(integer) 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;redis 127.0.0.1:6379&amp;gt; zadd w3cschool.cc 0 rabitmq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(integer) 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;redis 127.0.0.1:6379&amp;gt; ZRANGEBYSCORE w3cschool.cc 0 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1) &amp;quot;redis&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2) &amp;quot;mongodb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3) &amp;quot;rabitmq&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;参考文献：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.runoob.com/redis/redis-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redis教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/stephen-liu74/archive/2012/04/16/2370212.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redis学习手册&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h1&gt;&lt;p&gt;Redis 是一款完全开源免费的，遵守BSD协议，具有高性能的key-value数据库。Redis 与其他 key - value 缓存产品有以下三个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
    
    </summary>
    
    
      <category term="NoSQL" scheme="http://dupengchuan.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Java内存管理-垃圾回收机制</title>
    <link href="http://dupengchuan.github.io/2016/06/20/java-memory-management-gc/"/>
    <id>http://dupengchuan.github.io/2016/06/20/java-memory-management-gc/</id>
    <published>2016-06-20T10:41:03.000Z</published>
    <updated>2016-06-21T06:20:56.871Z</updated>
    
    <content type="html">&lt;h1 id=&quot;垃圾回收的意义&quot;&gt;&lt;a href=&quot;#垃圾回收的意义&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收的意义&quot;&gt;&lt;/a&gt;垃圾回收的意义&lt;/h1&gt;&lt;p&gt;在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以&lt;strong&gt;清除内存碎片&lt;/strong&gt;。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。垃圾回收能自动释放内存空间，减轻编程的负担。这使Java虚拟机具有一些优点。首先，它能使编程效率提高。在没有垃圾回收机制的时候，可能要花许多时间来解决一个难懂的存储问题。在用Java语言编程的时候，靠垃圾回收机制可大大缩短时间。其次是它保护程序的完整性， 垃圾回收是Java语言安全性策略的一个重要部份。&lt;/p&gt;
&lt;p&gt;垃圾回收的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾回收算法的不完备性，早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。当然随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解&lt;/p&gt;
&lt;h1 id=&quot;垃圾回收算法&quot;&gt;&lt;a href=&quot;#垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收算法&quot;&gt;&lt;/a&gt;垃圾回收算法&lt;/h1&gt;&lt;p&gt;Java虚拟机规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。　&lt;/p&gt;
&lt;h2 id=&quot;1-引用计数法&quot;&gt;&lt;a href=&quot;#1-引用计数法&quot; class=&quot;headerlink&quot; title=&quot;1. 引用计数法&quot;&gt;&lt;/a&gt;1. 引用计数法&lt;/h2&gt;&lt;p&gt;引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;br&gt;引用计数器增加了程序执行的开销，因为每次对象赋给新的变量，计数器加1，而每次现有对象出了作用域生，计数器减1。无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Main&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MyObject object1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyObject();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MyObject object2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyObject();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        object1.object = object2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        object2.object = object1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        object1 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        object2 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。&lt;/p&gt;
&lt;h2 id=&quot;2-tracing算法-Tracing-Collector&quot;&gt;&lt;a href=&quot;#2-tracing算法-Tracing-Collector&quot; class=&quot;headerlink&quot; title=&quot;2. tracing算法(Tracing Collector)&quot;&gt;&lt;/a&gt;2. tracing算法(Tracing Collector)&lt;/h2&gt;&lt;p&gt;tracing算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.&lt;/p&gt;
&lt;p&gt;所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。垃圾回收首先需要确定从根开始哪些是可达的和哪些是不可达的，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收&lt;/p&gt;
&lt;p&gt;tracing搜素算法示意图如下：&lt;br&gt;&lt;img src=&quot;http://img1.ph.126.net/tkELjpc_x5B8xgvV9ZhAbg==/6631482281582572195.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。&lt;/p&gt;
&lt;p&gt;java中可作为GC Root的对象有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;虚拟机栈中引用的对象（本地变量表）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法区中静态属性引用的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法区中常量引用的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本地方法栈中引用的对象（Native对象）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tracing算法示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.ph.126.net/qYYIR6D-XJpDxogemBZaow==/4912301293655253118.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成&lt;strong&gt;内存碎片&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;3-compacting算法-Compacting-Collector&quot;&gt;&lt;a href=&quot;#3-compacting算法-Compacting-Collector&quot; class=&quot;headerlink&quot; title=&quot;3. compacting算法(Compacting Collector)&quot;&gt;&lt;/a&gt;3. compacting算法(Compacting Collector)&lt;/h2&gt;&lt;p&gt;为了解决堆碎片问题，基于tracing的垃圾回收吸收了Compacting算法的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法&lt;br&gt;的收集器的实现中，一般增加句柄和句柄表。示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.ph.126.net/JNMapKiFfUytkpnmp2rJbQ==/6631504271815131004.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为标记-整理法用和标记-清除法一样的方式对存活对象进行标记，但在清除的时候不同，标记-整理法会对存活对象移动到堆的一端，并且要更新存活对象的引用，解决了内存空间碎片问题，但是增加了GC的开销。&lt;/p&gt;
&lt;h2 id=&quot;4-copying算法-Copying-Collector&quot;&gt;&lt;a href=&quot;#4-copying算法-Copying-Collector&quot; class=&quot;headerlink&quot; title=&quot;4. copying算法(Copying Collector)&quot;&gt;&lt;/a&gt;4. copying算法(Copying Collector)&lt;/h2&gt;&lt;p&gt;该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区域区，在对象区与空闲区域&lt;br&gt;的切换过程中，程序暂停执行。此时只有GC线程在运行。算法示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/CttHKMvVuNqRavc6_JpB_Q==/1996502009911249664.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。并且对于指定大小堆来说，需要两倍大小的内存，因为任何时候都只使用其中的一半。&lt;/p&gt;
&lt;h2 id=&quot;5-generation算法（Generation-Collector）&quot;&gt;&lt;a href=&quot;#5-generation算法（Generation-Collector）&quot; class=&quot;headerlink&quot; title=&quot;5. generation算法（Generation Collector）&quot;&gt;&lt;/a&gt;5. generation算法（Generation Collector）&lt;/h2&gt;&lt;p&gt;stop-and-copy垃圾收集器的一个缺陷是收集器必须复制所有的活动对象，这增加了程序等待时间，&lt;br&gt;这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代 (generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。&lt;/p&gt;
&lt;p&gt;分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。&lt;/p&gt;
&lt;p&gt;年轻代（Young Generation）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;年老代（Old Generation）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分代收集算法示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/zVQ_EyksSU66xLqCllrI0Q==/4832080925292717107.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;GC-垃圾收集器&quot;&gt;&lt;a href=&quot;#GC-垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;GC(垃圾收集器)&quot;&gt;&lt;/a&gt;GC(垃圾收集器)&lt;/h1&gt;&lt;p&gt;JVM分别对新生代和旧生代采用不同的垃圾回收机制&lt;/p&gt;
&lt;p&gt;新生代的GC：&lt;/p&gt;
&lt;p&gt;新生代通常存活时间较短，因此基于Copying算法来进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从eden到survivor，最后到旧生代，&lt;/p&gt;
&lt;p&gt;在执行机制上JVM提供了串行GC(SerialGC)、并行回收GC(ParallelScavenge)和并行GC(ParNew)&lt;br&gt;1)串行GC&lt;/p&gt;
&lt;p&gt;在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定&lt;/p&gt;
&lt;p&gt;2)并行回收GC&lt;/p&gt;
&lt;p&gt;在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数&lt;/p&gt;
&lt;p&gt;3)并行GC&lt;/p&gt;
&lt;p&gt;与旧生代的并发GC配合使用&lt;/p&gt;
&lt;p&gt;旧生代的GC：&lt;/p&gt;
&lt;p&gt;旧生代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。在执行机制上JVM提供了串行GC(SerialMSC)、并行GC(parallelMSC)和并发GC(CMS)，具体算法细节还有待进一步深入研究。&lt;/p&gt;
&lt;p&gt;以上各种GC机制是需要组合使用的，指定方式由下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指定方式&lt;/th&gt;
&lt;th&gt;新生代GC方式&lt;/th&gt;
&lt;th&gt;老年代GC方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseSerialGC&lt;/td&gt;
&lt;td&gt;Serial&lt;/td&gt;
&lt;td&gt;Serial Old(MSC)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseParallelGC&lt;/td&gt;
&lt;td&gt;Parallel Scavenge&lt;/td&gt;
&lt;td&gt;Parallel Old&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseConeMaskSweepGC&lt;/td&gt;
&lt;td&gt;ParNew&lt;/td&gt;
&lt;td&gt;CMS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseParNewGC&lt;/td&gt;
&lt;td&gt;ParNew&lt;/td&gt;
&lt;td&gt;Serial Old(MSC)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UserParallelOldGC&lt;/td&gt;
&lt;td&gt;Parallel Scavenge&lt;/td&gt;
&lt;td&gt;Parallel Old&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseConeMaskSweepGC&lt;br&gt;-XX:+UseSerialGC&lt;/td&gt;
&lt;td&gt;Serial&lt;/td&gt;
&lt;td&gt;CMS&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;不支持的组合&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-XX:+UseParNewGC &lt;br&gt; -XX:UseParallelOldGC&lt;/li&gt;
&lt;li&gt;-XX:+UseParNewGC &lt;br&gt; -XX:+UseSerialGC&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;组合示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img0.ph.126.net/hrWxdJyA82im7h3fH1znUA==/1995376110004736229.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;各个收集器介绍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Serial收集器（复制算法)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　新生代单线程收集器，标记和清理都是单线程，优点是简单高效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ParNew收集器(停止-复制算法)&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;　　新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Parallel Scavenge收集器(停止-复制算法)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Serial Old收集器(标记-整理算法)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　老年代单线程收集器，Serial收集器的老年代版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Parallel Old收集器(停止-复制算法)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CMS(Concurrent Mark Sweep)收集器（标记-清理算法)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择&lt;/p&gt;
&lt;h1 id=&quot;GC的执行机制&quot;&gt;&lt;a href=&quot;#GC的执行机制&quot; class=&quot;headerlink&quot; title=&quot;GC的执行机制&quot;&gt;&lt;/a&gt;GC的执行机制&lt;/h1&gt;&lt;p&gt;由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。&lt;/p&gt;
&lt;h2 id=&quot;Scavenge-GC&quot;&gt;&lt;a href=&quot;#Scavenge-GC&quot; class=&quot;headerlink&quot; title=&quot;Scavenge GC&quot;&gt;&lt;/a&gt;Scavenge GC&lt;/h2&gt;&lt;p&gt;一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。&lt;/p&gt;
&lt;h2 id=&quot;Full-GC&quot;&gt;&lt;a href=&quot;#Full-GC&quot; class=&quot;headerlink&quot; title=&quot;Full GC&quot;&gt;&lt;/a&gt;Full GC&lt;/h2&gt;&lt;p&gt;对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：&lt;/p&gt;
&lt;p&gt;　　1.年老代（Tenured）被写满&lt;/p&gt;
&lt;p&gt;　　2.持久代（Perm）被写满&lt;/p&gt;
&lt;p&gt;　　3.System.gc()被显示调用&lt;/p&gt;
&lt;p&gt;　　4.上一次GC之后Heap的各域分配策略动态变化&lt;/p&gt;
&lt;h1 id=&quot;内存泄漏问题&quot;&gt;&lt;a href=&quot;#内存泄漏问题&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏问题&quot;&gt;&lt;/a&gt;内存泄漏问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Static Vector v = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Vector();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Object o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    v.add(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;GC使用注意&quot;&gt;&lt;a href=&quot;#GC使用注意&quot; class=&quot;headerlink&quot; title=&quot;GC使用注意&quot;&gt;&lt;/a&gt;GC使用注意&lt;/h1&gt;&lt;h2 id=&quot;System-gc-方法&quot;&gt;&lt;a href=&quot;#System-gc-方法&quot; class=&quot;headerlink&quot; title=&quot;System.gc()方法&quot;&gt;&lt;/a&gt;System.gc()方法&lt;/h2&gt;&lt;p&gt;使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。在命令行中有一个参数-verbosegc可以查看Java使用的堆内存的情况，它的格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -verbosegc classfile
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看个例子：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestGC&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TestGC();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　    System.gc();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　    System.runFinalization();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　 &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，一个新的对象被创建，由于它没有使用，所以该对象迅速地变为不可达，程序编译后，执行命令： java -verbosegc TestGC 后结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Full GC 168K-&amp;gt;97K(1984K)， 0.0253873 secs]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;箭头前后的数据168K和97K分别表示垃圾收集GC前后所有存活对象使用的内存容量，说明有168K-97K=71K的对象容量被回收，括号内的数据1984K为堆内存的总容量，收集所需要的时间是0.0253873秒（这个时间在每次执行的时候会有所不同）。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;strong&gt;调用System.gc()也仅仅是一个请求(建议)。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;finalize-方法&quot;&gt;&lt;a href=&quot;#finalize-方法&quot; class=&quot;headerlink&quot; title=&quot;finalize()方法&quot;&gt;&lt;/a&gt;finalize()方法&lt;/h2&gt;&lt;p&gt;在JVM垃圾回收器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize（）。它的原型为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected void finalize() throws Throwable
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;　　在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃 圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由 finalize()方法。特殊的区域例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时 候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存 空间。&lt;/li&gt;
&lt;li&gt;又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。换言之，finalize()的主要用途是释放一些其他做法开辟的内存空间，以及做一些清理工作。因为在JAVA中并没有提够像“析构”函数或者类似概念 的函数，要做一些类似清理工作的时候，必须自己动手创建一个执行清理工作的普通方法，也就是override Object这个类中的finalize()方法。例如，假设某一个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦出，它可能永远 都不会被清理。如果在finalize()加入某一种擦除功能，当GC工作时，finalize()得到了调用，图像就会被擦除。要是GC没有发生，那么 这个图像就会被一直保存下来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一旦垃圾回收器准备好释放对象占用的存储空间，首先会去调用finalize()方法进行一些必要的清理工作。只有到下一次再进行垃圾回收动作的时候，才会真正释放这个对象所占用的内存空间。&lt;br&gt;　 　在普通的清除工作中，为清除一个对象，那个对象的用户必须在希望进行清除的地点调用一个清除方法。这与C++”析构函数”的概念稍有抵触。在C++中， 所有对象都会破坏（清除）。或者换句话说，所有对象都”应该”破坏。若将C++对象创建成一个本地对象，比如在堆栈中创建（在Java中是不可能 的，Java都在堆中），那么清除或破坏工作就会在”结束花括号”所代表的、创建这个对象的作用域的末尾进行。若对象是用new创建的（类似于 Java），那么当程序员调用C++的 delete命令时（Java没有这个命令），就会调用相应的析构函数。若程序员忘记了，那么永远不会调用析构函数，我们最终得到的将是一个内存”漏 洞”，另外还包括对象的其他部分永远不会得到清除。&lt;/p&gt;
&lt;p&gt;　 相反，Java不允许我们创建本地（局部）对象–无论如何都要使用new。但在Java 中，没有”delete”命令来释放对象，因为垃圾回收器会帮助我们自动释放存储空间。所以如果站在比较简化的立场，我们可以说正是由于存在垃圾回收机 制，所以Java没有析构函数。然而，随着以后学习的深入，就会知道垃圾收集器的存在并不能完全消除对析构函数的需要，或者说不能消除对析构函数代表的那 种机制的需要（原因见下一段。另外finalize()函数是在垃圾回收器准备释放对象占用的存储空间的时候被调用的，绝对不能直接调用 finalize()，所以应尽量避免用它）。若希望执行除释放存储空间之外的其他某种形式的清除工作，仍然必须调用Java中的一个方法。它等价于 C++的析构函数，只是没后者方便。&lt;/p&gt;
&lt;p&gt;在C++中所有的对象运用delete()一定会被销毁，而JAVA里的对象并非总会被垃圾回收器回收。In another word, 1 对象可能不被垃圾回收，2 垃圾回收并不等于“析构”，3 垃圾回收只与内存有关。也就是说，并不是如果一个对象不再被使用，是不是要在finalize()中释放这个对象中含有的其它对象呢？不是的。因为无论对 象是如何创建的，垃圾回收器都会负责释放那些对象占有的内存。&lt;/p&gt;
&lt;h2 id=&quot;触发主GC（Garbage-Collector）的条件&quot;&gt;&lt;a href=&quot;#触发主GC（Garbage-Collector）的条件&quot; class=&quot;headerlink&quot; title=&quot;触发主GC（Garbage Collector）的条件&quot;&gt;&lt;/a&gt;触发主GC（Garbage Collector）的条件&lt;/h2&gt;&lt;p&gt;JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。更值得关注的是主GC的触发条件,因为它对系统影响很明显。总的来说,有两个条件会触发主GC:&lt;/p&gt;
&lt;p&gt;　　1)当应用程序空闲时,即没有应用线程在运行时,GC会被调用。因为GC在优先级最低的线程中进行,所以当应用忙时,GC线程就不会被调用,但以下条件除外。&lt;/p&gt;
&lt;p&gt;　　2)Java堆内存不足时,GC会被调用。 当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足 内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。&lt;/p&gt;
&lt;p&gt;　　由于是否进行主GC由JVM根据系统环境决定,而系统环境在不断的变化当中,所以主GC的运行具有不确定性,无法预计它何时必然出现,但可以确定的是对一个长期运行的应用来说,其主GC是反复进行的。&lt;/p&gt;
&lt;h2 id=&quot;减少GC开销的措施&quot;&gt;&lt;a href=&quot;#减少GC开销的措施&quot; class=&quot;headerlink&quot; title=&quot;减少GC开销的措施&quot;&gt;&lt;/a&gt;减少GC开销的措施&lt;/h2&gt;&lt;p&gt;根据上述GC的机制,程序的运行会直接影响系统环境的变化,从而影响GC的触发。若不针对GC的特点进行设计和编码,就会出现内存驻留等一系列负面影响。为了避免这些影响,基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要显式调用System.gc()&lt;br&gt;此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽量减少临时对象的使用&lt;br&gt;临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象不用时最好显式置为Null&lt;br&gt;一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽量使用StringBuffer,而不用String来累加字符串&lt;br&gt;由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如 Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但 这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer 是可变长的,它在原有基础上进行扩增,不会产生中间对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;能用基本类型如Int,Long,就不用Integer,Long对象&lt;br&gt;基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽量少用静态对象变量&lt;br&gt;静态变量属于全局变量,不会被GC回收,它们会一直占用内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分散对象创建或删除的时间&lt;br&gt;集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片, 从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC 的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;关于垃圾回收的几点补充&quot;&gt;&lt;a href=&quot;#关于垃圾回收的几点补充&quot; class=&quot;headerlink&quot; title=&quot;关于垃圾回收的几点补充&quot;&gt;&lt;/a&gt;关于垃圾回收的几点补充&lt;/h2&gt;&lt;p&gt;经过上述的说明，可以发现垃圾回收有以下的几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;垃圾收集发生的不可预知性：由于实现了不同的垃圾回收算法和采用了不同的收集机制，所以它有可能是定时发生，有可能是当出现系统空闲CPU资源时发生，也有可能是和原始的垃圾收集一样，等到内存消耗出现极限时发生，这与垃圾收集器的选择和具体的设置都有关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;垃圾收集的精确性：主要包括2 个方面：（a）垃圾收集器能够精确标记活着的对象；（b）垃圾收集器能够精确地定位对象之间的引用关系。前者是完全地回收所有废弃对象的前提，否则就可能 造成内存泄漏。而后者则是实现归并和复制等算法的必要条件。所有不可达对象都能够可靠地得到回收，所有对象都能够重新分配，允许对象的复制和对象内存的缩 并，这样就有效地防止内存的支离破碎。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在有许多种不同的垃圾收集器，每种有其算法且其表现各异，既有当垃圾收集开始时就停止应用程序的运行，又有当垃圾收集开始时也允许应用程序的线程运行，还有在同一时间垃圾收集多线程运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;垃圾收集的实现和具体的JVM 以及JVM的内存模型有非常紧密的关系。不同的JVM 可能采用不同的垃圾收集，而JVM 的内存模型决定着该JVM可以采用哪些类型垃圾收集。现在，HotSpot 系列JVM中的内存系统都采用先进的面向对象的框架设计，这使得该系列JVM都可以采用最先进的垃圾收集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随着技术的发展，现代垃圾收集技术提供许多可选的垃圾收集器，而且在配置每种收集器的时候又可以设置不同的参数，这就使得根据不同的应用环境获得最优的应用性能成为可能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对以上特点，我们在使用的时候要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要试图去假定垃圾收集发生的时间，这一切都是未知的。比如，方法中的一个临时对象在方法调用完毕后就变成了无用对象，这个时候它的内存就可以被释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java中提供了一些和垃圾收集打交道的类，而且提供了一种强行执行垃圾收集的方法–调用System.gc()，但这同样是个不确定的方法。 Java 中并不保证每次调用该方法就一定能够启动垃圾收集，它只不过会向JVM发出这样一个申请，到底是否真正执行垃圾收集，一切都是个未知数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;挑选适合自己的垃圾收集器。一般来说，如果系统没有特殊和苛刻的性能要求，可以采用JVM的缺省选项。否则可以考虑使用有针对性的垃圾收集器，比 如增量收集器就比较适合实时性要求较高的系统之中。系统具有较高的配置，有比较多的闲置资源，可以考虑使用并行标记/清除收集器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关键的也是难把握的问题是内存泄漏。良好的编程习惯和严谨的编程态度永远是最重要的，不要让自己的一个小错误导致内存出现大漏洞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域(scope)后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的对象是否被监听，如果有，则要去掉监听器，然后再赋空值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;参考文献：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/sunniest/p/4575144.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;深入理解Java垃圾回收机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lemote.blog.163.com/blog/static/1748395072013111641050934/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;深入理解Java的垃圾回收机制(baidu上海研发中心面试题)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/laoyangHJ/articles/java_gc.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详细介绍Java垃圾回收机制&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垃圾回收的意义&quot;&gt;&lt;a href=&quot;#垃圾回收的意义&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收的意义&quot;&gt;&lt;/a&gt;垃圾回收的意义&lt;/h1&gt;&lt;p&gt;在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以&lt;strong&gt;清除内存碎片&lt;/strong&gt;。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存。
    
    </summary>
    
    
      <category term="Java" scheme="http://dupengchuan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存管理-内存分区和对象访问方式</title>
    <link href="http://dupengchuan.github.io/2016/06/20/java-memory-management/"/>
    <id>http://dupengchuan.github.io/2016/06/20/java-memory-management/</id>
    <published>2016-06-20T06:35:07.000Z</published>
    <updated>2016-06-20T10:02:06.777Z</updated>
    
    <content type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;对于从事C和C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民—既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-内存分区&quot;&gt;&lt;a href=&quot;#1-内存分区&quot; class=&quot;headerlink&quot; title=&quot;1. 内存分区&quot;&gt;&lt;/a&gt;1. 内存分区&lt;/h1&gt;&lt;p&gt;JVM运行时，为了便于管理，会将内存划分为若干区域，每个区域各司其职，分担不同的任务。每个分区的生命周期不尽相同，有的根据进程的启动而存在（如堆，方法区），有的则是根据线程的创建而创建（如vm栈，本地方法栈，和程序计数器），随着线程的结束而销毁。主要内存区域如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/4i3FlTEbGJfCClOOfshAIw==/6631768154605787498.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面来讲述一下各个分区的用途&lt;/p&gt;
&lt;h2 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h2&gt;&lt;p&gt;程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。&lt;/p&gt;
&lt;h2 id=&quot;VM栈&quot;&gt;&lt;a href=&quot;#VM栈&quot; class=&quot;headerlink&quot; title=&quot;VM栈&quot;&gt;&lt;/a&gt;VM栈&lt;/h2&gt;&lt;p&gt;与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。&lt;/p&gt;
&lt;p&gt;　　局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。&lt;/p&gt;
&lt;p&gt;　　其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出&lt;br&gt;StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;h2 id=&quot;本地方法栈&quot;&gt;&lt;a href=&quot;#本地方法栈&quot; class=&quot;headerlink&quot; title=&quot;本地方法栈&quot;&gt;&lt;/a&gt;本地方法栈&lt;/h2&gt;&lt;p&gt;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。&lt;/p&gt;
&lt;h2 id=&quot;JAVA堆&quot;&gt;&lt;a href=&quot;#JAVA堆&quot; class=&quot;headerlink&quot; title=&quot;JAVA堆&quot;&gt;&lt;/a&gt;JAVA堆&lt;/h2&gt;&lt;p&gt;对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。&lt;/p&gt;
&lt;p&gt;　　Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划&lt;br&gt;分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。&lt;/p&gt;
&lt;p&gt;　　根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;h2 id=&quot;方法区&quot;&gt;&lt;a href=&quot;#方法区&quot; class=&quot;headerlink&quot; title=&quot;方法区&quot;&gt;&lt;/a&gt;方法区&lt;/h2&gt;&lt;p&gt;方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。&lt;/p&gt;
&lt;p&gt;　　对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。&lt;/p&gt;
&lt;p&gt;　　Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;h3 id=&quot;运行时常量池&quot;&gt;&lt;a href=&quot;#运行时常量池&quot; class=&quot;headerlink&quot; title=&quot;运行时常量池&quot;&gt;&lt;/a&gt;运行时常量池&lt;/h3&gt;&lt;p&gt;运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言&lt;br&gt;并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;h1 id=&quot;2-对象访问方式&quot;&gt;&lt;a href=&quot;#2-对象访问方式&quot; class=&quot;headerlink&quot; title=&quot;2. 对象访问方式&quot;&gt;&lt;/a&gt;2. 对象访问方式&lt;/h1&gt;&lt;p&gt;介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　Object obj = new Object();&lt;/p&gt;
&lt;p&gt;假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实&lt;br&gt;现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。&lt;/p&gt;
&lt;p&gt;　　由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。 如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img0.ph.126.net/e46xvTiGq3JwR7iOy78EKg==/6631818732140669520.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果使用的是直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：&lt;br&gt;&lt;img src=&quot;http://img2.ph.126.net/hg4nZW67qDvCjEuG1j_QmQ==/4882746421101097352.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。&lt;/p&gt;
&lt;h1 id=&quot;3-栈帧结构&quot;&gt;&lt;a href=&quot;#3-栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;3. 栈帧结构&quot;&gt;&lt;/a&gt;3. 栈帧结构&lt;/h1&gt;&lt;p&gt;栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机里面从入栈到出栈的过程。&lt;br&gt;每一个栈帧都包括了局部变量表、操作数栈、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。&lt;br&gt;一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧（Current Stack Frame），这个栈帧所关联的方法称为当前方法（Current Method）。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作，栈帧的概念结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.ph.126.net/QZvtskLb5aYszQ219o8PSA==/1624955040653115592.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来我们将详细了解一下栈帧中的局部变量表、操作数栈、动态连接、方法返回地址等各个部分的作用和数据结构。&lt;/p&gt;
&lt;h2 id=&quot;局部变量表&quot;&gt;&lt;a href=&quot;#局部变量表&quot; class=&quot;headerlink&quot; title=&quot;局部变量表&quot;&gt;&lt;/a&gt;局部变量表&lt;/h2&gt;&lt;p&gt;局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。&lt;/p&gt;
&lt;p&gt;局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，虚拟机规范中并没有明确指明一个Slot应用占用空间大小，只是很有“导向性”地说明每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这种描述与明确指出“”有一些差别，它允许Slot的长度随着处理器、操作系统或虚拟机的不同而发生变化。不过无论如何，即使在64位虚拟机中使用了64位长度的内存空间来实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中和一致。既然前面提到了数据类型，在此顺便说一下，一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference和returnAddress八种类型。前面六种不需要多解释，大家都认识，而后面的reference是对象的引用。虚拟机规范既没有说明它的长度，也没有明确指出这个引用应有怎样的结构，但是一般来说，虚拟机实现至少都应当能从此引用中直接或间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。而returnAddress是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。对于64位的数据类型，虚拟机会以高位在前的方式为其分配两个连续的Slot空间。Java语言中明确规定的64位的数据类型只有long和double两种（reference类型则可能是32位也可能是64位）。值得一提的是，这里把long和double数据类型读写分割为两次32读写的做法类似，读者阅读到Java内存模型时可以对比一下。不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否是原子操作，都不会引起数据安全问题。&lt;/p&gt;
&lt;p&gt;虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot数量。如果是32位数据类型的变量，索引n就代表了使用第n个Slot，如果是64位数据类型的变量，则说明要使用第n和第n+1两个Slot。在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static的方法），那么局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。其余参数则按照参数表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。这样的设计不仅仅是为了节省栈空间，在某些情况下Slot的复用会直接影响到系统的垃圾收集行为，请看如下代码清单的演示：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LocalVariableTableTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[]args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] placeholder = newbyte[&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       System.gc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如上代码清单中的代码很简单，向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上“-verbose:gc”来看看垃圾收集的过程，发现在System.gc()运行后并没有回收掉这64MB的内存，下面是运行的结果：&lt;/p&gt;
&lt;p&gt;[Full GC 66933K-&amp;gt;66064K(126720K), 0.0097959 secs]&lt;/p&gt;
&lt;p&gt;没有回收掉placeholder所占的内存能说得过去，因为在执行System.gc()时，变量placeholder还处于作用域内，虚拟机自然不敢回收掉placeholder的内存。我们把代码修改一下，变成如下清单中的样子：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LocalVariableTableTest1&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[]args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] placeholder = newbyte[&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       System.gc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;加入了花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，在执行System.gc()的时候，placeholder已经不可能再被访问了，但执行一下这段程序，会发现运行结果如下，还是有64MB的内存没有被回收掉，这又是为什么呢？&lt;/p&gt;
&lt;p&gt;[Full GC 66933K-&amp;gt;66064K(126720K), 0.0070839 secs]&lt;/p&gt;
&lt;p&gt;在解释为什么之前，我们先对这段代码进行第二次修改，在调用System.gc()之前加入一行代码“int a = 0;”，变成如下代码清单的样子：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[]args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] placeholder = newbyte[&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.gc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个修改看起来很莫名其妙，但运行一下程序，却发现这次内存真的被正确回收了（这样的场景并不多见）：&lt;/p&gt;
&lt;p&gt;[Full GC 66933K-&amp;gt;528K(126720K), 0.0067665 secs]&lt;/p&gt;
&lt;p&gt;上面三段代码清单中，placeholder能否被回收的根本原因就是：局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为GC Roots一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微。但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再被使用的变量，手动将其设置为null值（用来代替“int a = 0;”，把变量对应的局部变量表Slot清空）就不是一个毫无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。但不应当对赋null值操作有过多的依赖，也没有必要把它当做一个普遍的编码方法来推广。以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法。&lt;br&gt;另外，赋null值的操作在经过虚拟机JIT编译器优化之后会被消除掉，这时候将变量设置为null实际上是没有意义的。字节码被编译为本地代码后，对GC Roots的枚举也与解释执行时期有所差别。&lt;br&gt;关于局部变量表，还有一点可能会对实际开发产生影响，就是局部变量不像前面介绍的类变量那样存在“准备阶段”。通过前一章的讲解，我们已经知道变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。所以不要认为Java中任何情况下都存在诸如整型变量默认为0、布尔型变量默认为false之类的默认值。如下代码清单所示：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[]args)&lt;/span&gt; &lt;/span&gt;&amp;#123;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码其实并不能运行，所幸编译器能在编译期间检查到并提示这一点。即便编译器能通过手动生成字节码的方式制造出下面的代码效果，字节码检验的时候也会被虚拟机发现，从而导致类加载失败。&lt;/p&gt;
&lt;h2 id=&quot;操作栈&quot;&gt;&lt;a href=&quot;#操作栈&quot; class=&quot;headerlink&quot; title=&quot;操作栈&quot;&gt;&lt;/a&gt;操作栈&lt;/h2&gt;&lt;p&gt;操作数栈也常被称为操作栈，它是一个后入先出（Last In First Out, LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。&lt;br&gt;当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。&lt;br&gt;举个例子，整数加法的字节码指令iadd在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值和并相加，然后将相加的结果入栈。&lt;br&gt;操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。再以上面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况。&lt;br&gt;另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的。但是大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，而无须进行额外的参数复制传递了，重叠的过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.ph.126.net/gbX9WjQoT4kmnVkUfMuIJg==/4918493743142881204.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。&lt;/p&gt;
&lt;h2 id=&quot;动态连接&quot;&gt;&lt;a href=&quot;#动态连接&quot; class=&quot;headerlink&quot; title=&quot;动态连接&quot;&gt;&lt;/a&gt;动态连接&lt;/h2&gt;&lt;p&gt;每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。我们知道Class文件的常量池有存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。&lt;/p&gt;
&lt;h2 id=&quot;方法返回地址&quot;&gt;&lt;a href=&quot;#方法返回地址&quot; class=&quot;headerlink&quot; title=&quot;方法返回地址&quot;&gt;&lt;/a&gt;方法返回地址&lt;/h2&gt;&lt;p&gt;当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。&lt;br&gt;另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。&lt;br&gt;无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。&lt;br&gt;方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。&lt;/p&gt;
&lt;h2 id=&quot;栈帧信息&quot;&gt;&lt;a href=&quot;#栈帧信息&quot; class=&quot;headerlink&quot; title=&quot;栈帧信息&quot;&gt;&lt;/a&gt;栈帧信息&lt;/h2&gt;&lt;p&gt;虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;参考文献：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://seandeng888.iteye.com/blog/2002490&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;java内存结构之栈帧结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JVM系列三：jvm参数设置、分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/gw811/archive/2012/10/18/2730117.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java内存管理：深入Java内存区域&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;对于从事C和C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民—既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://dupengchuan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机是如何启动的？</title>
    <link href="http://dupengchuan.github.io/2016/06/02/how-computers-boot-up/"/>
    <id>http://dupengchuan.github.io/2016/06/02/how-computers-boot-up/</id>
    <published>2016-06-02T05:53:30.000Z</published>
    <updated>2016-06-02T14:40:03.395Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文来自&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gustavo Duarte的博客&lt;/a&gt;，本人出于兴趣翻译过来，原文地址：&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-computers-boot-up/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How Computer Boot up&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面的一篇博文讲述了Intel计算机的&lt;a href=&quot;http://dupengchuan.me/2016/05/31/motherboard-chipsets-and-the-memory-map/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;主板芯片结构以及内存映射&lt;/a&gt;，这些属于为计算机启动的初始化阶段，计算机启动是一个复杂多阶段并且有趣的过程。下面是一个流程图：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/_N-Mf1KiaxbqiX8V5WCyfg==/6631579038605486672.png&quot; alt=&quot;bootProcess&quot;&gt;&lt;/p&gt;
&lt;p&gt;当你按下开机键的时候，一切变开始运转了。主板一旦被供电，它就初始化自己的固件（芯片组和其他附属组件）并启动CPU。如果此时硬件失败（比如CPU故障或者不存在），那么你的系统很有可能除了那旋转的风扇什么反应都没有。一些主板可能会发出蜂鸣告警CPU故障或者缺失，但据我的经验，风扇故障是最常见的情况。甚至有时候USB或者其它也设备能够引起这种情况发生，这时候拔下一些不必要的设备是一个解决办法。你可以通过逐步移除的方法来定位故障设备。&lt;/p&gt;
&lt;p&gt;如果一切顺利，CPU开始运行。在多处理器或者多核的系统，一个CPU核心被动态的选择成为引导处理器（BSP），然后运行所有的BIOS和kernel初始化代码。其余的处理器称为应用处理器（AP），这时候它们依旧停留在原来的状态直到后来被内核激活。Intel的CPU已经发展了那么多年，但它们是完全向后兼容，所以现代的CPU和1978年的&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_8086&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;intel 8086&lt;/a&gt;启动还是很相似，上电之后它们做哪些工作是很已经确定的。在上电后的早期状态，处理器在处在&lt;a href=&quot;http://en.wikipedia.org/wiki/Real_mode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实模式&lt;/a&gt;（禁用内存&lt;a href=&quot;http://en.wikipedia.org/wiki/Paging&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;分页&lt;/a&gt;）。这个就像早期的MS-DOS系统，可以寻址1MB内存空间，并且任何代码都可以存放在该空间的任何位置，这里没有内存保护和特权的概念。&lt;/p&gt;
&lt;p&gt;CPU的大部分&lt;a href=&quot;http://en.wikipedia.org/wiki/Processor_register&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;寄存器&lt;/a&gt;都有已经定义好的明确的功能，比如指令指针（EIP）寄存器，里面存储了CPU正在执行的指令的内存地址。Intel CPU使用基址寻址访问向量程序。即使上电时只有1MB的的内存可以被访问，一个隐藏的基址（本质上是一个偏移量）被加到EIP,因此第一条指令在0xFFFFFFF0(4G内存的最后16个字节，远远高于1M空间)。这个神奇的地址被称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Reset_vector&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;复位向量&lt;/a&gt;，是现代化CPU的一个标准。&lt;/p&gt;
&lt;p&gt;主板确保在复位向量的跳转指令可跳转到存储器上BIOS程序的入口点。这个跳转指令也隐含清除了上电的时候产生的基址。所有的这些存储单元都有CPU需要的内容。这多亏了芯片（包括BIOS）的&lt;a href=&quot;http://duartes.org/gustavo/blog/post/motherboard-chipsets-memory-map&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存映射&lt;/a&gt;机制。此时RAM模块在这些区域之间也存在没有被使用的内存。内存区域相关的例子如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.ph.126.net/nUyi_jsfkqNY5i1PwMwA9g==/4939322891419790476.png&quot; alt=&quot;bootMemoryRegions&quot;&gt;&lt;/p&gt;
&lt;p&gt;CPU跳转到BIOS程序并执行，初始化一些硬件。之后BIOS开始进行&lt;a href=&quot;http://en.wikipedia.org/wiki/Power_on_self_test&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上电自检&lt;/a&gt;（POST），这个过程中检测各种计算机组件。如果缺少显卡会引发BIOS程序停止，并且发出蜂鸣警告，这样你就知道哪里出了问题（由于显卡出了问题，所以不可能从屏幕获得信息）。如果显卡正常运行，我们可能感觉计算机好像是正常的：制造商的商标打印了，内存也开始检测。其他的自检失败，像缺少键盘将会导致BIOS停止并将错误信息显示在屏幕上。POST包括硬件检测和初始化，POST之后会整理出所有资源-中断、内存范围、I/O端口（PCI设备）。现代的BIOS根据进行&lt;a href=&quot;http://en.wikipedia.org/wiki/ACPI&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;高级配置和启动选项&lt;/a&gt;，建立一个启动表，里面保存了计算机上的设备，这个表稍后将会被内核用到。&lt;/p&gt;
&lt;p&gt;POST之后，BIOS准备启动一个操作系统，首先要找到操作系统在哪里：硬盘，CD-ROM，软盘等等，这里，用户可以配置BIOS的选择启动设备的顺序。BIOS如果没有合适的启动设备，就会给出信息： “Non-System Disk Error”。一个坏掉的硬盘可能会导致这个问题。但愿不要这样，希望BIOS找到一个正常工作的硬盘顺利启动。&lt;/p&gt;
&lt;p&gt;BIOS读取硬盘的第一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Disk_sector&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;扇区&lt;/a&gt;的512个字节。这个被称作&lt;a href=&quot;http://en.wikipedia.org/wiki/Master_boot_record&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;主引导记录&lt;/a&gt;，通常它包括两部分：操作系统相关的引导程序和磁盘分区表。BIOS并不关心它们有什么用，BIOS只是仅仅将这个512字节加载到内存的0x7c00的位置，然后跳转到MBR中的引导程序继续执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img0.ph.126.net/c5QoVMKGUiOOubfIdSLraA==/6631565844465954720.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;MBR中的引导程序可以是Windows的MBR loader,或者是Linux loader比如LILO或者GRUB,或者甚至有可能是一个病毒。相比较引导程序，分区表则是标准化的格式：它总共长64个字节，16个字节表示一个分区（所以在一个磁盘上可以有不同分区也可以有不同的系统）。通常，Microsoft MBR代码会查看分区表，找到那个被标记为活动状态的分区，加载该分区上引导扇区，并运行上面的代码。引导扇区是一个分区的第一个扇区，注意和磁盘的第一个扇区的区别不一样。如果分区表上有错误，你会看到：“无效的分区表”或者“找不到操作系统”。这些消息不是来自BIOS，而是来自MBR上的引导程序。至于消息的内容与特定的MBR引导程序有关。&lt;/p&gt;
&lt;p&gt;随着时代的发展，引导程序已经变得越来越复杂和灵活。Linux引导程序LILO和GRUB可以引导多种操作系统、文件系统而且可以被配置。它们的MBR代码已经不是必须引导上面所说的活动分区。功能上的流程如下：&lt;/p&gt;
&lt;p&gt;MBR包括boot loader的第一阶段，GRUB就在这个阶段。&lt;/p&gt;
&lt;p&gt;由于MBR空间有限，MBR没有足够的空间加载从磁盘加载包含其他引导代码的扇区。这个扇区有可能是这个分区的引导扇区，但是也可以被硬编码到MBR代码区。&lt;/p&gt;
&lt;p&gt;MBR代码加上那些在第二步加载代码，然后读取一个包含bootloader第二阶段代码的文件。GRUB中是grub/stage2,Windows中是c:\NTLDR。如果步骤2失败，Windows系统你会得到像：“NTLDR is missing”。阶段2的代码读取一个启动配置文件（linux中是grub.conf，windows中是boot.ini）。然后展示用户选择启动系统的界面或者是直接启动系统（仅仅存在一个启动项）&lt;/p&gt;
&lt;p&gt;此时，bootloader代买需要启动一个内核。它必须知道文件系统是什么然后才可以去分区读取内核。在Linux中，这意味着去读取名字差不多是“vmlinuz-2.6.22-14-server”的文件，加载进内存并且跳转到内核启动代码。在WIndows2003中，一些内核启动代码和内核镜像是分开的。实际上嵌入到了NYLDR文件中。进行几个初始化之后，NTDLR才加载镜像c:\Windows\System32\ntoskrnl.exe。然后就想GRUB做的一样，跳转到内核的程序执行。&lt;/p&gt;
&lt;p&gt;这里有一个值得一提的问题（）。当前的Linux 内核镜像即使经过压缩，也不能放进RAM最开始地那640K地址空间(实模式下可访问)。我的Ubuntu内核压缩之后是1.7M。但是bootloader通过BIOS读取磁盘数据必须运行在实模式中，因此内核显然是获取不到的。解决办法就是引入了&lt;a href=&quot;http://en.wikipedia.org/wiki/Unreal_mode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;虚拟模式&lt;/a&gt;。这个并不是一个真正的处理器模式（我希望Intel的工程师被允许在这方面有兴趣），但是是一项技术，程序为了能够通过BIOS例程访问超过1MB以上的地址空间在实模式和保护模式之间切换。如果你读过GRUB源码，你会看到这些转换（看stage2中的real_to_prot和prot_to_real）。当BIOS将内核加载到内存中，最后处理器又会切换回实模式。&lt;/p&gt;
&lt;p&gt;正如图1中展示的，我们现在处在从“引导加载程序”到“早期的内核初始化”阶段。接下来的事情会变得麻烦，内核解压，动态初始化。下一篇文章是Linux内核初始化的一个介绍，我会给出源码的连接。当然Windows我不能这样做。但是我会指出值得注意的地方。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot;&gt;Gustavo Duarte的博客&lt;/a&gt;，本人出于兴趣翻译过来，原文地址：&lt;a href=&quot;http://duartes.org/gustavo/blog/post/how-computers-boot-up/&quot;&gt;How Computer Boot up&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面的一篇博文讲述了Intel计算机的&lt;a href=&quot;http://dupengchuan.me/2016/05/31/motherboard-chipsets-and-the-memory-map/&quot;&gt;主板芯片结构以及内存映射&lt;/a&gt;，这些属于为计算机启动的初始化阶段，计算机启动是一个复杂多阶段并且有趣的过程。下面是一个流程图：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Arch" scheme="http://dupengchuan.github.io/tags/Arch/"/>
    
  </entry>
  
  <entry>
    <title>主板芯片和内存映射原理</title>
    <link href="http://dupengchuan.github.io/2016/05/31/motherboard-chipsets-and-the-memory-map/"/>
    <id>http://dupengchuan.github.io/2016/05/31/motherboard-chipsets-and-the-memory-map/</id>
    <published>2016-05-31T08:37:10.000Z</published>
    <updated>2016-06-02T05:52:15.090Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;这篇博文翻译自&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gustavo Duarte&lt;/a&gt;博客上的一篇博文，笔者出于兴趣，同时也是学习，翻译过来，原文： &lt;a href=&quot;http://duartes.org/gustavo/blog/post/motherboard-chipsets-memory-map/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Motherboard Chipsets and the Memory Map&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了阐明现在操作系统内核如何工作，我打算写一些关于计算机内部实现原理的文章。希望对那些对这方面有兴趣但是却没有经验的电脑爱好者和程序员们有所帮助。计算机的内部实现是我的一个爱好，因此我们主要关注点在Linux、Windows操作系统以及Intel处理器。这篇博文主要讲述了基于Intel处理器的主板布局，CPU怎么样访问内存以及系统内存映射。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先让我们看一下现代基于Intel处理器的计算机架构是什么样子的。下面这幅图主要展示了主板上的主要组件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/syfL7tvt2FaivsIy765tJg==/4819414551340637687.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现代主板由南桥芯片组和北桥芯片组构成&lt;/p&gt;
&lt;p&gt;看到这幅图，记住最关键一点，那就是CPU不知道他连接的是什么设备。CPU通过引脚连接外面的世界，但是它不关心连接的是什么。虽然可能是一台计算机的主板，但是也有可能是烤面包机，网络路由器，CPU实验板等等。CPU有三种方式和外面通信：内存地址、IO地址和中断。我们现在只讨论主板和内存。&lt;/p&gt;
&lt;p&gt;CPU通往外面的大门是连接到北桥的前端总线，CPU通过前端总线读写内存。它使用一些引脚传送它想要读或者写的物理内存地址，使用另外一些引脚传送或者接收数据。Intel Core2 QX6600有33根传送内存地址的引脚（地址空间2^33个内存地址）和64根发送和接收数据的引脚（数据宽度是64bit或者8字节）。这允许CPU能够寻址的内存空间大小为64GB（2^33 * 8 byte）尽管大部分的芯片只使用了8G的内存。&lt;/p&gt;
&lt;p&gt;我们曾经认为程序不停地读取和写入的只有RAM,事实上大部分内存请求也是经过北桥芯片到了RAM模块，但并不是全部。内存物理地址也可以映射到各种各样的主板上的设备上（这种通信被称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Memory-mapped_IO&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存映射I/O&lt;/a&gt;）。这些设备有显卡、大部分PCI设备（比图，扫描仪或者SCSI卡）以及存储BIOS程序的&lt;a href=&quot;http://en.wikipedia.org/wiki/Flash_memory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;闪存&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当北桥芯片接收到一个内存请求，北桥芯片根据内存地址映射决定最终请求的设备是RAM还是显卡。对于每一个内存地址段，通过内存映射可以知道属于哪个设备。地址空间的大部分地址映射到了RAM,但是当如果没有内存映射告诉芯片哪个设备需要处理这些请求，那些不在RAM的地址空间就造成了内存地址空洞（640KB-1MB这部分地址是设备使用的但是如果没有设备使用就相当于这段内存没有用）。当内存地址为显卡和PCI设备预留了地址空间的时候，将会引起更大的空洞。这也就是&lt;a href=&quot;http://support.microsoft.com/kb/929605&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;为什么32位的操作系统在使用4GRAM的时候会出问题&lt;/a&gt;。下面的这幅图展示了一个4G地址空间上的一个内存映射。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/TMKxjy78Awc82dLBKfijVA==/6631513067907784718.png&quot; alt=&quot;memoryLayout&quot;&gt;&lt;/p&gt;
&lt;p&gt;Intel系统前4G内存模型&lt;/p&gt;
&lt;p&gt;实际的地址范围取决于具体的主板和实际的设备，但是大部分的Core 2系统和上面很类似。所有的褐色段被映射到RAM之外的设备。这些地址可以被主板总线直接使用。而在CPU内部（比如，运行的程序需要写）这些地址是逻辑地址，它们在被总线访问之前必须先被CPU转成物理地址。&lt;/p&gt;
&lt;p&gt;逻辑地址转换为物理地址的过程比较复杂，依赖于CPU运行模式（实模式、32位保护模式和64位保护模式）。不考虑内存转换机制，CPU的模式决定了可以访问多大物理地址空间。比如，如果CPU运行在32位保护模式，那么它的寻址空间是4GB(但是开启&lt;a href=&quot;http://en.wikipedia.org/wiki/Physical_address_extension&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Physical Address Extension&lt;/a&gt;是个例外，这里暂不讨论)。由于最前面的大约1GB内存映射给主板设备，CPU能够实际使用的只有1~3GB的RAM空间（有时候会更少-我的Vista系统只有2.4G可用）。如果CPU运行在&lt;a href=&quot;http://en.wikipedia.org/wiki/Real_mode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实模式&lt;/a&gt;（系统启动早期使用的模式），那么它能够寻址1GB的RAM空间。另外，64位保护模式可以寻址64GB内存空间（虽然很少有芯片支持）。在64位模式，系统在访问那些被主板设备占据的内存的时候,有可能使用超过总RAM的物理地址空间。这就是所谓的可回收内存，在芯片的支持下完成。&lt;/p&gt;
&lt;p&gt;下一篇我们将讲述系统启动过程，从按开机键到bootloader跳转到内核，将控制权交给内核。如果你想要了解更多关于这方面的内容，我强烈推荐你看&lt;a href=&quot;http://www.intel.cn/content/www/cn/zh/processors/architectures-software-developer-manuals.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intel手册&lt;/a&gt;。我是从大的方向把握，但Intel手册写上面的非常详细和准确。这里列举一些。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://download.intel.com/design/chipsets/datashts/31760701.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intel G35 参考手册&lt;/a&gt;描述了一些支持Core 2的代表性芯片。是本篇博文的主要来源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://download.intel.com/design/processor/datashts/31559205.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intel Core 2 Quad-Core-Q600 参考手册&lt;/a&gt;是一个处理器手册。它介绍了处理器上面的每个引脚（实际上并没有太大的实际意义，如果你对它们进行分类，发现也没有多少）。很神秘，也很让人着迷。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.intel.com/products/processor/manuals/index.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intel 软件开发手册&lt;/a&gt;都很不错。通俗全面地阐明了有关架构的各种事情。卷1和卷3A有一些很不错的内容（不要被卷这个字吓到，这个卷很小，而且你可以有选择地看）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.pixelbeat.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pádraig Brady&lt;/a&gt;建议我链接到Ulrich Drepper一篇&lt;a href=&quot;https://www.akkadia.org/drepper/cpumemory.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于内存的的文章&lt;/a&gt;，写的非常的好。我一直在等待有一篇（当然越多越好）关于内存的博文可以链接这篇文章，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇博文翻译自&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot;&gt;Gustavo Duarte&lt;/a&gt;博客上的一篇博文，笔者出于兴趣，同时也是学习，翻译过来，原文： &lt;a href=&quot;http://duartes.org/gustavo/blog/post/motherboard-chipsets-memory-map/&quot;&gt;Motherboard Chipsets and the Memory Map&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了阐明现在操作系统内核如何工作，我打算写一些关于计算机内部实现原理的文章。希望对那些对这方面有兴趣但是却没有经验的电脑爱好者和程序员们有所帮助。计算机的内部实现是我的一个爱好，因此我们主要关注点在Linux、Windows操作系统以及Intel处理器。这篇博文主要讲述了基于Intel处理器的主板布局，CPU怎么样访问内存以及系统内存映射。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Arch" scheme="http://dupengchuan.github.io/tags/Arch/"/>
    
  </entry>
  
  <entry>
    <title>SSH远程登录</title>
    <link href="http://dupengchuan.github.io/2016/05/30/ssh-login/"/>
    <id>http://dupengchuan.github.io/2016/05/30/ssh-login/</id>
    <published>2016-05-30T04:22:52.000Z</published>
    <updated>2016-05-30T10:15:04.528Z</updated>
    
    <content type="html">&lt;p&gt;SSH为Secure Shell的缩写，是位于传输层与应用程序之间的安全传输协议，能够保证信道的安全性。SSH在*uix上的一个重要应用就是远程登录。&lt;/p&gt;
&lt;p&gt;SSH提供了两种验证方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于口令的安全验证，知道账号和口令，输入口令可以登录到远程主机，但是每次登陆都需要输入口令，无法避免“中间人”攻击。&lt;/li&gt;
&lt;li&gt;基于密钥的安全验证，客户机需要有自己的一对密钥，把公钥放在需要访问的服务服务器上。通过使用ssh-agent和ssh-add可以做到免口令登陆。&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;基于口令的安全验证&quot;&gt;&lt;a href=&quot;#基于口令的安全验证&quot; class=&quot;headerlink&quot; title=&quot;基于口令的安全验证&quot;&gt;&lt;/a&gt;基于口令的安全验证&lt;/h1&gt;&lt;p&gt;当发送一个登陆命令时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh user@host
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;查询$HOME/.ssh/known_host里面是否有host对应的公钥&lt;/li&gt;
&lt;li&gt;如果找到host对应的公钥，不会有是否连接远程主机的提示，客户端用公钥加密口令发功给远程主机，远程主机解密，如果口令正确则登陆成功&lt;/li&gt;
&lt;li&gt;如果没有找到host对应的公钥，则向host请求公钥，之后登陆界面会显示远程主机的指纹，是否连接&lt;/li&gt;
&lt;li&gt;如果yes，则执行步骤2，并将远程主机公钥存入$HOME/.ssh/known_host文件中，供下次使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;流程图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.ph.126.net/uWUDtGxI3xhg_EE_W3cpVg==/6631698885372855341.png&quot; alt=&quot;sorry&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;基于密钥的安全验证&quot;&gt;&lt;a href=&quot;#基于密钥的安全验证&quot; class=&quot;headerlink&quot; title=&quot;基于密钥的安全验证&quot;&gt;&lt;/a&gt;基于密钥的安全验证&lt;/h1&gt;&lt;p&gt;验证过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;local host将自己的公钥发送给remote host。&lt;/li&gt;
&lt;li&gt;remote host查询自己的authorized_keys文件，如果存在该公钥则给local host 发送一个chanllenge(用local host的公钥加密一个随机数)。&lt;/li&gt;
&lt;li&gt;local host使用自己的私钥加密这个随机数发送给remote&lt;/li&gt;
&lt;li&gt;remote检查随机数，确定验证公钥的合法性，给local host反馈结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img0.ph.126.net/nfQy6oBEaoTDnhcFBO8qZQ==/1993687260144251892.png&quot; alt=&quot;sorry&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;基于密钥验证登录实践&quot;&gt;&lt;a href=&quot;#基于密钥验证登录实践&quot; class=&quot;headerlink&quot; title=&quot;基于密钥验证登录实践&quot;&gt;&lt;/a&gt;基于密钥验证登录实践&lt;/h1&gt;&lt;p&gt;步骤很简单&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成本地公私钥对&lt;/li&gt;
&lt;li&gt;本地公钥添加到remot的$HOME/.ssh/authorized_keys文件中&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;本地生成密钥对&quot;&gt;&lt;a href=&quot;#本地生成密钥对&quot; class=&quot;headerlink&quot; title=&quot;本地生成密钥对&quot;&gt;&lt;/a&gt;本地生成密钥对&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以为自己的私钥设置口令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -P &amp;quot;xxxx&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自己的私钥设置口令之后每次登陆都需要输入自己的口令，使用ssh-agent和ssh-add可以做到把口令的放入代理不用自己每次输入。&lt;/p&gt;
&lt;h2 id=&quot;添加公钥到remote&quot;&gt;&lt;a href=&quot;#添加公钥到remote&quot; class=&quot;headerlink&quot; title=&quot;添加公钥到remote&quot;&gt;&lt;/a&gt;添加公钥到remote&lt;/h2&gt;&lt;p&gt;方法1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ssh-copy-id user@host
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;tips:&lt;/p&gt;
&lt;p&gt;远程配置文件/etc/ssd/sshd_config去掉以下注释，然后重启ssh服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#RSAAuthentication yes
#PublickeyAuthentication yes
#AuthorizedKeyFile .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh user@host &amp;apos;mkdir -p .ssh &amp;amp;&amp;amp; cat &amp;gt;&amp;gt; .ssh/authorized_keys&amp;apos; &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法3&lt;/p&gt;
&lt;p&gt;  scp id_rsa.pub user@host:.ssh/&lt;br&gt;  cat id_rsa.pub &amp;gt;&amp;gt; authorized_keys&lt;/p&gt;
&lt;h2 id=&quot;设置免口令登陆&quot;&gt;&lt;a href=&quot;#设置免口令登陆&quot; class=&quot;headerlink&quot; title=&quot;设置免口令登陆&quot;&gt;&lt;/a&gt;设置免口令登陆&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ssh-add $HOME/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 输入自己的口令，之后登陆就交给代理处理，不需要输入口令&lt;/p&gt;
&lt;p&gt;遇到的问题：&lt;/p&gt;
&lt;p&gt;Could not open a connection to your authentication agent&lt;/p&gt;
&lt;p&gt;通过下面命令解决了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-agent bash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不用之后一定要清除，否则别人用你的电脑一样可以免口令登陆&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-agent -k
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看私钥指纹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-add -l
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;权限问题可能会造成不是自己想要的结果，比如id_rsa文件group和other如果有了写权限，基于密钥的验证就会降级为基于口令,设置.ssh目录的最小权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod 700 .ssh
chmod 600 .ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SSH总的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.ph.126.net/2wPg2IDX5YSLWin_EGsRJw==/6631745064861226711.jpg&quot; alt=&quot;sorry&quot;&gt;&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSH原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://7056824.blog.51cto.com/69854/403669/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用ssh公钥密钥自动登陆linux服务器&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;SSH为Secure Shell的缩写，是位于传输层与应用程序之间的安全传输协议，能够保证信道的安全性。SSH在*uix上的一个重要应用就是远程登录。&lt;/p&gt;
&lt;p&gt;SSH提供了两种验证方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于口令的安全验证，知道账号和口令，输入口令可以登录到远程主机，但是每次登陆都需要输入口令，无法避免“中间人”攻击。&lt;/li&gt;
&lt;li&gt;基于密钥的安全验证，客户机需要有自己的一对密钥，把公钥放在需要访问的服务服务器上。通过使用ssh-agent和ssh-add可以做到免口令登陆。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="http://dupengchuan.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Bash中的快捷键</title>
    <link href="http://dupengchuan.github.io/2016/05/29/bash-shortcuts/"/>
    <id>http://dupengchuan.github.io/2016/05/29/bash-shortcuts/</id>
    <published>2016-05-29T11:43:28.000Z</published>
    <updated>2016-05-30T04:23:23.556Z</updated>
    
    <content type="html">&lt;p&gt;生活在shell bash上的人熟记Bash中快捷键可以大大提高敲命令和查看的速度，提高工作的效率。在这人力记一下笔者常用的一些快捷键。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; class=&quot;headerlink&quot; title=&quot;光标移动&quot;&gt;&lt;/a&gt;光标移动&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + 左箭头&lt;/td&gt;
&lt;td&gt;向左移动一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + 右箭头&lt;/td&gt;
&lt;td&gt;向右移动一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + a&lt;/td&gt;
&lt;td&gt;移动到行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + e&lt;/td&gt;
&lt;td&gt;移动到行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;编辑操作&quot;&gt;&lt;a href=&quot;#编辑操作&quot; class=&quot;headerlink&quot; title=&quot;编辑操作&quot;&gt;&lt;/a&gt;编辑操作&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + u&lt;/td&gt;
&lt;td&gt;清除光标左边所有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + k&lt;/td&gt;
&lt;td&gt;清除光标右边所有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + d&lt;/td&gt;
&lt;td&gt;从光标位置开始删除到单词尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + w&lt;/td&gt;
&lt;td&gt;从光标位置开始删除到单词首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + r&lt;/td&gt;
&lt;td&gt;搜索历史命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + .&lt;/td&gt;
&lt;td&gt;使用上一次命令最后一个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + c&lt;/td&gt;
&lt;td&gt;拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + v&lt;/td&gt;
&lt;td&gt;粘贴&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;控制操作&quot;&gt;&lt;a href=&quot;#控制操作&quot; class=&quot;headerlink&quot; title=&quot;控制操作&quot;&gt;&lt;/a&gt;控制操作&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + l&lt;/td&gt;
&lt;td&gt;清屏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + PgUP&lt;/td&gt;
&lt;td&gt;向上翻页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + PgDn&lt;/td&gt;
&lt;td&gt;向下翻页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + s&lt;/td&gt;
&lt;td&gt;阻止屏幕输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + q&lt;/td&gt;
&lt;td&gt;允许屏幕输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + z&lt;/td&gt;
&lt;td&gt;挂起进程(之后进程处于T状态)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;生活在shell bash上的人熟记Bash中快捷键可以大大提高敲命令和查看的速度，提高工作的效率。在这人力记一下笔者常用的一些快捷键。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="http://dupengchuan.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell流程控制语句学习</title>
    <link href="http://dupengchuan.github.io/2016/05/29/shell-grammar/"/>
    <id>http://dupengchuan.github.io/2016/05/29/shell-grammar/</id>
    <published>2016-05-29T01:44:21.000Z</published>
    <updated>2016-05-29T04:47:35.172Z</updated>
    
    <content type="html">&lt;p&gt;本博文主要讲述Shell *sh 的流程控制语句,主要有分支语句和循环语句，分支语句包括if、case。循环语句有for、while、until。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;分支语句&quot;&gt;&lt;a href=&quot;#分支语句&quot; class=&quot;headerlink&quot; title=&quot;分支语句&quot;&gt;&lt;/a&gt;分支语句&lt;/h1&gt;&lt;h2 id=&quot;if-语句&quot;&gt;&lt;a href=&quot;#if-语句&quot; class=&quot;headerlink&quot; title=&quot;if 语句&quot;&gt;&lt;/a&gt;if 语句&lt;/h2&gt;&lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if cond1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;elif cond2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tips:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;else 之后没有 then 命令&lt;/li&gt;
&lt;li&gt;最后一定要用 fi 结束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些是语法上的强制要求，违反就会运行报错&lt;/p&gt;
&lt;h2 id=&quot;case语句&quot;&gt;&lt;a href=&quot;#case语句&quot; class=&quot;headerlink&quot; title=&quot;case语句&quot;&gt;&lt;/a&gt;case语句&lt;/h2&gt;&lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;case $value in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;regex1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;... #多个case&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;esac&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tip:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最后一个case可加可不加;;,其他case最后必须有;;命令&lt;/li&gt;
&lt;li&gt;最后必须要有 esac 结束命令&lt;/li&gt;
&lt;li&gt;匹配条件可以有多个，用 | 并列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;匹配规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;任意多个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;? 单个字符&lt;/li&gt;
&lt;li&gt;[] 在[]里面的任意单个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Demo&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;case $1 in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1|2|3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo &amp;quot;input: &amp;quot; $1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4?)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo &amp;quot;input: &amp;quot; 40~49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[a-z]|[A-Z]j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo &amp;quot;input: letter&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo &amp;quot;any&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;esac&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;循环语句&quot;&gt;&lt;a href=&quot;#循环语句&quot; class=&quot;headerlink&quot; title=&quot;循环语句&quot;&gt;&lt;/a&gt;循环语句&lt;/h1&gt;&lt;h2 id=&quot;for语句&quot;&gt;&lt;a href=&quot;#for语句&quot; class=&quot;headerlink&quot; title=&quot;for语句&quot;&gt;&lt;/a&gt;for语句&lt;/h2&gt;&lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for i in $(seq start end)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;notes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环变量和起始和结束变量都没有带 $ 符号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Demo&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for i in $(seq 0 10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo hello world!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;while语句&quot;&gt;&lt;a href=&quot;#while语句&quot; class=&quot;headerlink&quot; title=&quot;while语句&quot;&gt;&lt;/a&gt;while语句&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;while condition&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Demo&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;read i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;declare -i target=10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while ((i&amp;lt;target))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    echo $i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let i++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;until语句&quot;&gt;&lt;a href=&quot;#until语句&quot; class=&quot;headerlink&quot; title=&quot;until语句&quot;&gt;&lt;/a&gt;until语句&lt;/h2&gt;&lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;until condition&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cmd n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tips:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件为假的时候执行循环&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Demo&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;read i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;declare -i target=10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;until ((i &amp;gt; target))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo $1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ((i++))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;和c语言比较,关键字条件之间必须有空格&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本博文主要讲述Shell *sh 的流程控制语句,主要有分支语句和循环语句，分支语句包括if、case。循环语句有for、while、until。&lt;br&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="http://dupengchuan.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>安装Scrapy</title>
    <link href="http://dupengchuan.github.io/2016/05/27/scrapy-setup/"/>
    <id>http://dupengchuan.github.io/2016/05/27/scrapy-setup/</id>
    <published>2016-05-27T13:45:36.000Z</published>
    <updated>2016-05-28T07:54:38.975Z</updated>
    
    <content type="html">&lt;h1 id=&quot;安装python环境&quot;&gt;&lt;a href=&quot;#安装python环境&quot; class=&quot;headerlink&quot; title=&quot;安装python环境&quot;&gt;&lt;/a&gt;安装python环境&lt;/h1&gt;&lt;p&gt;下载&lt;a href=&quot;https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;python 2.7.11&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf Python-2.7.11.tgz

cd Python-2.7.11

./configure --prefix=/usr/local

make &amp;amp;&amp;amp; make all &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;安装setuptools&quot;&gt;&lt;a href=&quot;#安装setuptools&quot; class=&quot;headerlink&quot; title=&quot;安装setuptools&quot;&gt;&lt;/a&gt;安装setuptools&lt;/h1&gt;&lt;p&gt;使用&lt;a href=&quot;bootstrap.pypa.io&quot;&gt;ez_setup.py&lt;/a&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget --no-check-certificate https://bootstrap.pypa.io/ez_setup.py

python ez_setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;安装pip&quot;&gt;&lt;a href=&quot;#安装pip&quot; class=&quot;headerlink&quot; title=&quot;安装pip&quot;&gt;&lt;/a&gt;安装pip&lt;/h1&gt;&lt;p&gt;使用&lt;a href=&quot;bootstrap.pypa.io&quot;&gt;get-pip.py&lt;/a&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget --no-check-certificate https://bootstrap.pypa.io/get-pip.py

python get-pip.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用该方法会自动安装 setuptools 和 wheel&lt;/p&gt;
&lt;p&gt;使用安装包： &lt;a href=&quot;https://pypi.python.org/pypi/pip/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pip-8.1.2&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf pip-8.1.2.tar.gz

cd pip-8.1.2

python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用此方法安装必须先安装好setuptools&lt;/p&gt;
&lt;h1 id=&quot;安装Scrapy&quot;&gt;&lt;a href=&quot;#安装Scrapy&quot; class=&quot;headerlink&quot; title=&quot;安装Scrapy&quot;&gt;&lt;/a&gt;安装Scrapy&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;pip install Scrapy
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;遇到的问题： Failed building wheel for cryptography&lt;/p&gt;
&lt;p&gt;cryptography安装不成功，这个包是有关https使用的，系统中要有支持的库，看到了这里&lt;a href=&quot;http://stackoverflow.com/questions/22073516/failed-to-install-python-cryptography-package-with-pip-and-setup-py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;,里面通过安装以下包解决了问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo yum install gcc libffi-devel python-devel openssl-devel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用rpm命令，检查发现缺少了libffi-devel&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install libffi-devel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装之后顺利安装完成Scrapy&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cat &amp;gt; myspider.py &amp;lt;&amp;lt;EOF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  from scrapy import Spider, Item, Field&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  class Post(Item):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    title = Field()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  class BlogSpider(Spider):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = &#39;kevin&#39;blog&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    start_urls = [&#39;dupengchuan.me&#39;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def parse(self, response):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return [Post(title=e.extract()) for e in response.css(&quot;h2 a::text&quot;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EOF&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scrap runspider myspider
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行结果正常这里不再显示&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;OS： CentOS 6.5&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装python环境&quot;&gt;&lt;a href=&quot;#安装python环境&quot; class=&quot;headerlink&quot; title=&quot;安装python环境&quot;&gt;&lt;/a&gt;安装python环境&lt;/h1&gt;&lt;p&gt;下载&lt;a href=&quot;https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz&quot;&gt;python 2.7.11&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf Python-2.7.11.tgz

cd Python-2.7.11

./configure --prefix=/usr/local

make &amp;amp;&amp;amp; make all &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://dupengchuan.github.io/tags/Python/"/>
    
      <category term="Crawler" scheme="http://dupengchuan.github.io/tags/Crawler/"/>
    
  </entry>
  
  <entry>
    <title>FTP服务器安装以及配置</title>
    <link href="http://dupengchuan.github.io/2016/05/27/vsftpd/"/>
    <id>http://dupengchuan.github.io/2016/05/27/vsftpd/</id>
    <published>2016-05-27T10:41:18.000Z</published>
    <updated>2016-05-28T03:47:22.718Z</updated>
    
    <content type="html">&lt;p&gt;今天安装了一下FTP服务器，记录一下安装过程，以及遇到的问题&lt;/p&gt;
&lt;p&gt;OS： CentOS6.5&lt;/p&gt;
&lt;p&gt;vsftpd Version： 2.2.2&lt;/p&gt;
&lt;h1 id=&quot;安装vsftpd&quot;&gt;&lt;a href=&quot;#安装vsftpd&quot; class=&quot;headerlink&quot; title=&quot;安装vsftpd&quot;&gt;&lt;/a&gt;安装vsftpd&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;yum install vsftpd
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;p&gt;vaftpd的配置文件：/etc/vsftpd/vsftpd.conf&lt;/p&gt;
&lt;p&gt;关掉匿名登录开启本地用户登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;anonimous_enable=NO

local_enable=YES
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;设置开机启动&quot;&gt;&lt;a href=&quot;#设置开机启动&quot; class=&quot;headerlink&quot; title=&quot;设置开机启动&quot;&gt;&lt;/a&gt;设置开机启动&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用可交互的界面设置（空格选中）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ntsysv
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chkconfig vsftpd on   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;启动vsftpd&quot;&gt;&lt;a href=&quot;#启动vsftpd&quot; class=&quot;headerlink&quot; title=&quot;启动vsftpd&quot;&gt;&lt;/a&gt;启动vsftpd&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;service vsftpd start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现不能访问，可以ping通，说明不是网络的问题，telnet ip 21。telnet不上,应该是防火墙的原因&lt;/p&gt;
&lt;h1 id=&quot;配置防火墙&quot;&gt;&lt;a href=&quot;#配置防火墙&quot; class=&quot;headerlink&quot; title=&quot;配置防火墙&quot;&gt;&lt;/a&gt;配置防火墙&lt;/h1&gt;&lt;p&gt;allow all ftp incoming connections&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p tcp --dport 21 -m state --state ESTABLISHED -j ACCEPT

iptables -A OUTPUT -p tcp --sport 21 -m state --state NEW,ESTABLISHED -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Enable active ftp transfers&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p tcp --dport 20 -m state --state ESTABLISHED,RELATED -j ACCEPT

iptables -A OUTPUT -p tcp --sport 20 -m state --state ESTABLISHED -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Enable passive ftp transfers&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p tcp --sport 1024:65535 --dport 1024:65535 -m state --state ESTABLISHED -j ACCEPT

iptables -A OUTPUT -p tcp --sport 1024:65535 --dport 1024:65535 -m state --state ESTABLISHED,RELATED -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主动模式中，使用端口20发送数据，所以是对20端口配置&lt;/p&gt;
&lt;p&gt;被动模式的端口号是动态申请的，所以指定的是一个范围&lt;/p&gt;
&lt;p&gt;防火墙配置好之后记得保存规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service iptables save
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启服务，发现还是不能登录，报错如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;500 OOPS: cannot change directory:/home/*******

500 OOPS: child died
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个权限的问题，google一下，发现是SELinux做了约束，需要修改相应配置&lt;/p&gt;
&lt;h1 id=&quot;修改SELinux&quot;&gt;&lt;a href=&quot;#修改SELinux&quot; class=&quot;headerlink&quot; title=&quot;修改SELinux&quot;&gt;&lt;/a&gt;修改SELinux&lt;/h1&gt;&lt;p&gt;方法一、关闭SELinux&lt;/p&gt;
&lt;p&gt;SELinux的启动配置文件是： /etc/selinux/config&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELINUX=disabled
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法二、开启某些功能&lt;/p&gt;
&lt;p&gt;网上有的人这么做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setsebool -P ftpd_disable_trans on
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是我这里找不到 ftpd_disable_trans，可能是系统版本的问题，经过尝试，终于用下面命令搞定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setsebool -P ftp_home_dir on
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;一些关于SELinux的命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setsebool xxx on/off　　＃设置状态

getsetools -a　　＃结合grep可以看到有关ftp的约束

sestatus　　＃查看selinux是否开启
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;今天安装了一下FTP服务器，记录一下安装过程，以及遇到的问题&lt;/p&gt;
&lt;p&gt;OS： CentOS6.5&lt;/p&gt;
&lt;p&gt;vsftpd Version： 2.2.2&lt;/p&gt;
&lt;h1 id=&quot;安装vsftpd&quot;&gt;&lt;a href=&quot;#安装vsftpd&quot; class=&quot;headerlink&quot; title=&quot;安装vsftpd&quot;&gt;&lt;/a&gt;安装vsftpd&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;yum install vsftpd
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://dupengchuan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>你的操作系统是如何运行的？</title>
    <link href="http://dupengchuan.github.io/2016/05/24/when-dos-your-os-run/"/>
    <id>http://dupengchuan.github.io/2016/05/24/when-dos-your-os-run/</id>
    <published>2016-05-24T05:37:08.000Z</published>
    <updated>2016-05-26T15:19:40.795Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;这篇博文来自于&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gustavo Duarte&lt;/a&gt;的科普博客，本人出于兴趣翻译过来，原文：&lt;a href=&quot;http://duartes.org/gustavo/blog/post/when-does-your-os-run/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;When Does Your OS Run?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里有一个问题，就是在你阅读到我这篇博文中的这句话的时候，你的操作系统是否正在运行？还是只有浏览器在运行？还是它们都处于空闲状态，正在等待你分配任务？&lt;/p&gt;
&lt;p&gt;这些问题虽然简单但却深入到整个软件运行过程。为了准确地回答这些问题，我们要在大脑中对操作系统行为有一个良好的运行状态模型，即操作系统依次通知进程执行，安全方面以及故障的决策。希望通过这一些列博文，我们能够在脑海里建立起这种模型。本文主要使用Linux作为主要的操作系统，OS X和Windows也会偶尔出现。某些地方我会附上源码链接以方便那些想要深入研究的人。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有一个基本公理：即在任何时刻，在CPU上有且仅有一个任务在运行。这个任务通常是一个进程，像浏览器，音乐播放器等等，但是也有可能是操作系统线程，但它也是一个任务。同一时刻CPU上的任务不可能是两个或者多个，也不会是0个。&lt;/p&gt;
&lt;p&gt;这个听起来很抽象，举个例子，如果你的音乐播放器一直占用着CPU,并且不让其他任务占有，这种情况，你不能打开一个工具（Windows是任务管理器，Linux使用shell命令）去杀死它，此时移动或者点击鼠标都是无效的，因为操作系统不会让它们执行，那么你可能被一直卡在”The fox”（一首歌的名字）。&lt;/p&gt;
&lt;p&gt;以上便是中断的由来。就像神经系统打断大脑的正常运行，带来外界的刺激，一声巨响或者拍一下肩膀。主板上的&lt;a href=&quot;http://duartes.org/gustavo/blog/post/motherboard-chipsets-memory-map&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;芯片&lt;/a&gt;为了传达外部事件（按下键盘，网络数据包到达，硬盘读取完毕等等）也会中断CPU。硬件外设、中断控制器以及CPU一起完成中断过程。&lt;/p&gt;
&lt;p&gt;控制任务执行时间是通过中断实现的。在&lt;a href=&quot;http://duartes.org/gustavo/blog/post/kernel-boot-process&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;系统启动过程&lt;/a&gt;中，内核启动一个定时器周期性的发出中断请求，比如10ms一次。当一个中断发生后，CPU执行中断处理程序，更新系统的状态，观察一些事件，比如是否当前进程执行时间超过了时间片？TCP连接是否超时？中断给了内核一个机会思考这些问题并采取合适方法去解决。这就像你设置了定时报警器，特定的时间点回去提醒你去做什么事情：我现在应该做什么？是否有更重要的事情做？&lt;/p&gt;
&lt;p&gt;内核通过中断周期性地占有CPU,中断使操作系统像时钟一样滴答滴答地运行。但中断不止这些，中断也用来处理一些软件事件，比如整数溢出和缺页错误，这些中断没有外部硬件的参与。中断是进入系统内核最重要和最频繁的入口，因此很多电子工程师对中断作为操作系统运行的机制表示担心。&lt;/p&gt;
&lt;p&gt;不说废话了，让我们来一些实际行动。下面是一个基于英特尔酷睿i5的网卡中断过程。现在该图有链接，点击获得更多信息。例如从设备到它的linux驱动。(ps：原文里面的图片有链接)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img1.ph.126.net/mZPBFG0B6_SQ9BV1_veMxQ==/61924494977343331.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们来看看这张图。首先，由于有很多中断源，如果硬件只是告诉CPU:“嗨，有事情发生了！”，然后离开，那么CPU不知道发生了什么，显然这不会有多大的实际意义。因此每个设备都被安排了一个中断请求路线(LRQ)。所有的中断请求都会到达中断请求控制器，中断请求控制器根据LRQ依次将中断请求映射为中断向量（0-255表示）。当中断到达CPU,CPU面对的是一个友好的明确的中断向量。而不是各种各样的外部硬件。&lt;/p&gt;
&lt;p&gt;反过来，CPU有一个指向255个函数数组的指针，这些函数被内核支持，每一个函数对应一个特定的中断向量。在后面我们将会看到这个数组——中断描述符表（IDT）。&lt;/p&gt;
&lt;p&gt;每当一个中断到达，CPU使用它的中断向量作为索引进入IDT然后运行相应的中断处理函数。这是一个特殊的函数调用，因为发生在当前运行任务的上下文，操作系统以最小的开销去响应外部事件。因此web服务器如果在向你发送数据的时候调用一个函数，这是不是很酷或者很可怕？下面我们展示一个场景：CPU正在运行一个Vim命令时，来了一个中断。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img0.ph.126.net/u-7hwJNC-174Sx4O1zkXJw==/1156299204428848479.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意中断的到来如何导致内核模式和&lt;a href=&quot;http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ring 0&lt;/a&gt;的切换，但是不会改变活动任务。这就好像Vim变魔术一般调用一个函数直接进入内核。但是Vim依然在这里，它的&lt;a href=&quot;http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;地址空间&lt;/a&gt;没有变，正在等待函数返回。&lt;/p&gt;
&lt;p&gt;终于要写完了，兴奋的时刻！，哈哈，我知道我还没有回答那个开放问题，并且还引入了新问题。但是当你读到我这句话的时候，如果你仍旧怀疑操作系统到底是什么状态。相信你可以找到答案,因为我们之前已经讲解了了操作系统的动态运行模型。这个浏览器的问题也变得清晰了。如果你还有问题，尤其是这个博文发表之后，我会尽快在博文里面或者评论里面回答你的问题。之后的会在RSS和Twitter上做解答。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇博文来自于&lt;a href=&quot;http://duartes.org/gustavo/blog/&quot;&gt;Gustavo Duarte&lt;/a&gt;的科普博客，本人出于兴趣翻译过来，原文：&lt;a href=&quot;http://duartes.org/gustavo/blog/post/when-does-your-os-run/&quot;&gt;When Does Your OS Run?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里有一个问题，就是在你阅读到我这篇博文中的这句话的时候，你的操作系统是否正在运行？还是只有浏览器在运行？还是它们都处于空闲状态，正在等待你分配任务？&lt;/p&gt;
&lt;p&gt;这些问题虽然简单但却深入到整个软件运行过程。为了准确地回答这些问题，我们要在大脑中对操作系统行为有一个良好的运行状态模型，即操作系统依次通知进程执行，安全方面以及故障的决策。希望通过这一些列博文，我们能够在脑海里建立起这种模型。本文主要使用Linux作为主要的操作系统，OS X和Windows也会偶尔出现。某些地方我会附上源码链接以方便那些想要深入研究的人。&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://dupengchuan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://dupengchuan.github.io/2016/05/22/hello-world/"/>
    <id>http://dupengchuan.github.io/2016/05/22/hello-world/</id>
    <published>2016-05-22T05:18:13.523Z</published>
    <updated>2016-05-26T15:21:23.015Z</updated>
    
    <content type="html">&lt;p&gt;很早就想有一个自己的博客，今天终于初步搭建好了。&lt;/p&gt;
&lt;p&gt;使用的是github pages托管网页,一个静态博客。&lt;/p&gt;
&lt;p&gt;Hexo静态网页生成工具,有关Hexo的使用可以从官网获得帮助：&lt;a href=&quot;http://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hexo.io&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;主题使用的是even，连接：&lt;a href=&quot;https://github.com/ahonn/hexo-theme-even&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ahonn/hexo-theme-even&lt;/a&gt;，在此谢谢ahonn。&lt;/p&gt;
&lt;p&gt;争取以后养成写博客的习惯&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n1.itc.cn/img8/wb/smccloud/recom/2015/09/06/144154649059751427.JPEG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;很早就想有一个自己的博客，今天终于初步搭建好了。&lt;/p&gt;
&lt;p&gt;使用的是github pages托管网页,一个静态博客。&lt;/p&gt;
&lt;p&gt;Hexo静态网页生成工具,有关Hexo的使用可以从官网获得帮助：&lt;a href=&quot;http://hexo.io&quot;&gt;http://hexo.io&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="http://dupengchuan.github.io/tags/life/"/>
    
  </entry>
  
</feed>
